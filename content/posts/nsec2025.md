---
layout: post
title: "NorthSec CTF 2025"
author: cryptax
date: 2025-05-19
images: []
draft: false
tags:
- northsec
- CTF
---

# Containers

The theme of this CTF was a cruise ship, *CVSS Bonsecours* (conference and CTF taking place at *Marché Bonsecours* in Montréal).

Description:

*While the Bonsecours is obviously a cruise ship, civilian ships can be chartered to carry cargo in containers. These containers are smaller than what you are used to see for haulage. To request a physical container, you need to prove ownership of the container to the stevedor.*

*This cargo is interesting to us. Try to extract the hidden secrets in this container.*

We provided a file, `small.tar`

```
docker load -i small.tar
docker run --rm -it small:p1
```

## Getting information from the container

After loading `small.tar`, we see three new Docker images:

```
$ docker images | grep small
small                                          p1        35398aa0475c   3 weeks ago     95.9MB
small                                          p3        dbae34b95de9   3 weeks ago     95.9MB
small                                          p2        9e78658f2d4a   3 weeks ago     95.9MB
```

When we run the p1 container as requested, a password is requested:

![](/images/nsec-container.png)

With `docker inspect`, we see that the binary which is run is `/1680322826`

```
$ docker inspect 6bd9e24c85b7
[
    {
        "Id": "6bd9e24c85b79491d8bfdfc282c6b249374788ea98754e64125989d1d31c98c5",
        "Created": "2025-05-18T22:54:00.388126426Z",
        "Path": "/entrypoint",
        "Args": [
            "ruby",
            "/1680322826"
        ],
```

## Understanding the Ruby program

We attach to the container `docker exec -it 6bd9e24c85b7 /bin/sh` and once in the container, we list the file:

```
/ # cat 1680322826 
require 'base64'
eval(Base64.urlsafe_decode64([90, 71, 86, 109, 73, 72, 103, 103, 80, 83, 66, 108, 100, 109, 70, 115, 75, 67, 74, 98, 78, 84, 69, 115, 73, 68, 85, 119, 76, 67, 65, 49, 77, 83, 119, 103, 78, 68, 103, 115, 73, 68, 85, 50, 76, 67, 65, 49, 77, 67, 119, 103, 78, 84, 73, 115, 73, 68, 85, 50, 76, 67, 65, 48, 79, 67, 119, 103, 78, 84, 66, 100, 73, 105, 107, 117, 98, 87, 70, 119, 75, 67, 89, 54, 89, 50, 104, 121, 75, 83, 53, 113, 98, 50, 108, 117, 76, 110, 82, 118, 88, 50, 107, 75, 90, 71, 86, 109, 73, 71, 53, 118, 75, 67, 111, 112, 73, 68, 48, 103, 90, 88, 104, 112, 100, 67, 65, 119, 76, 110, 78, 49, 89, 50, 77, 106, 90, 88, 78, 122, 67, 109, 85, 57, 82, 69, 70, 85, 81, 83, 53, 121, 90, 87, 70, 107, 76, 110, 78, 119, 98, 71, 108, 48, 76, 109, 49, 104, 99, 72, 116, 112, 100, 67, 53, 48, 98, 49, 57, 112, 76, 110, 78, 108, 98, 109, 81, 111, 79, 108, 52, 115, 101, 67, 108, 57, 67, 109, 107, 57, 90, 50, 86, 48, 99, 121, 89, 117, 89, 50, 104, 118, 98, 88, 65, 75, 90, 83, 53, 54, 97, 88, 65, 111, 97, 83, 53, 105, 101, 88, 82, 108, 99, 121, 107, 117, 98, 87, 70, 119, 101, 50, 108, 48, 76, 110, 74, 108, 90, 72, 86, 106, 90, 83, 103, 54, 80, 84, 48, 112, 102, 83, 53, 121, 90, 87, 112, 108, 89, 51, 82, 55, 97, 88, 82, 57, 76, 109, 86, 104, 89, 50, 104, 55, 98, 109, 57, 57, 67, 109, 53, 118, 75, 69, 82, 66, 86, 69, 69, 112, 73, 71, 108, 109, 73, 71, 85, 117, 99, 50, 108, 54, 90, 83, 65, 104, 80, 83, 66, 112, 76, 110, 78, 112, 101, 109, 85, 75].map(&:chr).join))
__END__
3230824790 3230824784 3230824794 3230824704 3230824704 3230824787 3230824786 3230824786 3230824790 3230824710 3230824711 3230824785 3230824708 3230824789 3230824788 3230824785 3230824795 3230824704 3230824788 3230824786 3230824794 3230824790 3230824795 3230824710 3230824710 3230824784 3230824704 3230824787 3230824789 3230824704 3230824791 3230824795/
```

It's an "obfuscated"/"hardened" ruby file.
We have an array of integers which are convered to characters and form a Base64 string. So, we copy paste the array in [CyberChef](https://gchq.github.io/CyberChef) and select the following rules:

1. From Decimal
2. From Base64

We get the following program:

```
def x = eval("[51,50,51,48,56,50,52,56,48,50]").map(&:chr).join.to_i
def no(*) = exit 0.succ!ess
e=DATA.read.split.map{it.to_i.send(:^,x)}
i=gets.chomp
e.zip(i.bytes).map{it.reduce(:==)}.reject{it}.each{no}
no(DATA) if e.size != i.size
```

It creates a key, `x`, and transforms each integers of the array in a character and joins the characters in a string.
Then, basically, it XORs each integers of the Ruby's DATA section (after `__END__`) with the key and compares with user input character by character. It exits if a character is wrong.

## Decrypting the password

So, we just need to XOR the data integers with the key and this will compute the expected password:

```python
data = """
3230824790 3230824784 3230824794 3230824704 3230824704 3230824787 3230824786 3230824786 3230824790 3230824710 3230824711 3230824785 3230824708 3230824789 3230824788 3230824785 3230824795 3230824704 3230824788 3230824786 3230824794 3230824790 3230824795 3230824710 3230824710 3230824784 3230824704 3230824787 3230824789 3230824704 3230824791 3230824795
"""

x = 3230824802 & 0xffffffff

numbers = list(map(int, data.split()))
password = ''.join(chr((n ^ x)& 0xff) for n in numbers)

print("Password :", password)
```

We run our password decoding program. The password is `428bb1004de3f7639b60849dd2b17b59`.
We enter that password in the container, and it replies:

```
Congrats, you found part 1 of the flag! Here it is: FLAG-6b44cae751
```

We submit the flag:

```
../askgod submit FLAG-6b44cae751                                               
You sent a valid flag, but no points have been granted.
Message: [containers] small.tar 1/3 of the flag, 2 more to go
```

HEY! It's correct, but we didn't get any point! Grrrr!
We need to do the same with contains p2 and p3.

## Container p2

## Container p3